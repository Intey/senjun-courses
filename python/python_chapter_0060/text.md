# Глава 6. Встроенные типы данных: списки, кортежи, диапазоны
> Питон — это эксперимент по определению степени свободы разработчика. Слишком много свободы, и никто не сможет читать чужой код; слишком мало, и это убьет выразительность.  
Гвидо ван Россум

Спиcок и неизменяемый список (кортеж) — коллекции, которые легко встретить чуть ли не в каждом скрипте на питоне. А диапазон (range) — тип, незаменимый в связке с `for` для определения количества итераций цикла. Остановимся на каждом из этих типов-последовательностей поподробнее.

## Списки
Список (list) — гетерогенная последовательность, не требующая от элементов уникальности и позволяющая обращаться к ним по индексам. Что-то вроде массива динамической длины: можно модифицировать элементы списка, удалять и добавлять новые.

## Создание списка
При создании списка используются квадратные скобки `[]` либо конструктор `list()`.

Объявление списка строк:
```python
langs = ["haskell", "erlang", "scala"]
```

Объявление пустого списка:
```python
langs = []
```

Список — это гетерогенный контейнер: он запросто может содержать элементы разных типов, в том числе и вложенные списки:
```python
random_stuff = [2, 2, False, 9.1, ["A", 8], "search"]
```

Внимательно прочитайте объявление списка `links`. Как думаете, сколько в нем элементов и какие они?
```python
links = ["realpython.com", "docs.python.org" "python.org"]
print(links)
```
Легко ошибиться и сказать, что элементов три. Но если присмотреться, заметно, что между последним и пред-последним элементами пропущена запятая. Идущие одна за другой строки питон просто склеивает, поэтому в коллекцию попадет всего два элемента, а консольный вывод списка будет таким:
```
['realpython.com', 'docs.python.orgpython.org']
```

Так что при объявлении списка не забывайте расставлять запятые!

А вот пустой список, объявленный с помощью конструктора:
```python
langs = list()
```

...И еще один пример с подвохом. Как считаете, что окажется в списке, если при создании вызвать конструктор `list()` от строки?
```python
langs = list("elixir")
print(langs)
```
Естественно предположить, что `langs` — список, состоящий из единственного элемента. Но это не так.
Чтобы ответить правильно, нужно знать, что конструктор `list()` в качестве аргумента принимает итерабельный объект. В нашем случае `list()` проходит по строке и добавляет в список каждую букву по отдельности. Поэтому список `langs` состоит из 6-ти элементов:
```
['e', 'l', 'i', 'x', 'i', 'r']
```

А чтобы получить желаемый результат, вместо вызова конструктора от итерируемого объекта нужно инициализировать список напрямую: `langs = ["elixir"]`.

## Работа с элементами списка
Индексация в списке начинается с 0. Для получения значения элемента по индексу применяются все те же квадратные скобки.

Выведите в консоль значение второго элемента списка `sequences`. {.task_text}
```python {.task_source #python_chapter_0060_task_0010}
sequences = ["str", "list", "tuple", "range"]
```
```python {.task_hint}
print(sequences[1])
```

При обращении к элементам списков, вложенных в другие списки, индексы указываются в последовательно идущих квадратных скобках:
```python
matrix = [[1, 2], [3, 4], [5, 6], [7, 8]]

val = matrix[2][1]
matrix[1][0] = val

print(matrix)
```
В данном примере переменной `val` присвоено значение 6: это 1-ый (начиная с нуля) элемент второго вложенного списка внутри `matrix`. Затем элемент со значением 3 был заменен на 6:
```
[[1, 2], [6, 4], [5, 6], [7, 8]]
```

Из примера видно, что в отличие от строк, элементы списков можно модифицировать. Со строками подобный фокус не пройдет:
```python
s = "Lists & tuples"
s[8] = "T"
```

При попытке модификации элемента строки по индексу генерируется исключение:
```
TypeError: 'str' object does not support item assignment
```

Как и при посимвольном доступе к строкам, при обращении к элементам списка допускается использовать отрицательные индексы. Особенно это удобно для получения последнего элемента:

```python
collections = ["sequences", "sets", "mappings"]
last_val = collections[-1]
```
В этом примере переменной `last_val` присваивается строка "mappings".

Замените элемент "E" матрицы на значение "NEW", используя доступ по отрицательным индексам. Выведите `matrix` на экран.{.task_text}
```python {.task_source #python_chapter_0060_task_0020}
matrix = [["A", "B", "C"], ["D", "E", "F"]]
```
```python {.task_hint}
matrix[-1][-2] = "NEW"
```

Так как списки в питоне — это **упорядоченные** коллекции с доступом по индексу, то два списка, содержащих одинаковые элементы, но в разном порядке, считаются разными объектами:
```python
l = [1, 2, "bonjour"]
m = [1, "bonjour", 2]

print(l == m)
```
В этом примере сравнение вернуло `False`.

Если же содержимое списков поэлементно совпадает, то списки считаются равными:
```python
l = [16, 32]
m = [16, 32]

print(l == m)
```
В этом примере сравнение вернуло "True".

К спискам, так же как и к строкам, применим синтаксис **слайсов.**

Создайте переменную `l2` и сохраните в нее копию списка `l1`, используя синтаксис слайсов. Затем выведите `l2` в консоль. {.task_text}
```python {.task_source #python_chapter_0060_task_0030}
l1 = ["pointer", "reference"]
```
```python {.task_hint}
l2 = l1[:]
```

Выведите в консоль слайс списка `lst` от индекса 2 до индекса 8 включительно с шагом 2. {.task_text}
```python {.task_source #python_chapter_0060_task_0040}
lst = [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```
```python {.task_hint}
print(lst[2:9:2])
```

С помощью слайсов удобно получать перевернутый список: для этого достаточно опустить начальный и конечный индексы слайса, а в качестве шага указать -1.

Выведите в консоль элементы списка `lst` в обратном порядке. Используйте для этого слайс. {.task_text}
```python {.task_source #python_chapter_0060_task_0050}
lst = [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```
```python {.task_hint}
print(lst[::-1])
```

Интересная фишка питона: через слайс элементы списка можно не только получать, но и присваивать!
```python
l = ["A", "B", "C", "D", "E", "F", "G", "H"]
l[2:5] = [10, 20, 30, 40, 50, 60]
print(l)
```
После присваивания слайсу список `l` выглядит следующим образом:
```
['A', 'B', 10, 20, 30, 40, 50, 60, 'F', 'G', 'H']
```

Причем совершенно необязательно следить за тем, чтобы длина присваиваемого списка совпадала с длиной слайса - назначения. Слайс подстроится: если количество присваиваемых элементов больше, то они будут добавлены. Если меньше, то слайс ужмется.

Что произойдет с исходным списком и слайсами, на него ссылающимися, если один из таких слайсов изменить? Приведет ли изменение слайса к изменению исходного списка?

```python
lst = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print("lst", lst)

sl1 = lst[1:7]
print("sl1", sl1)

sl2 = lst[2:4]
print("sl2", sl2)

sl1[1:5] = []

print("\nAfter sl1 reassignment:")
print("lst", lst)
print("sl1", sl1)
print("sl2",  sl2)
```

Ответ — нет, не приведет. При изменении слайса, ссылающегося на список, слайс потеряет связь с исходным списком:
```
lst [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
sl1 [1, 2, 3, 4, 5, 6]
sl2 [2, 3]

After sl1 reassignment:
lst [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
sl1 [1, 6]
sl2 [2, 3]
```

В этом списке последовательность степеней двойки прервана символами. Исправьте это при помощи присвоения слайсу.{.task_text}
```python {.task_source #python_chapter_0060_task_0060}
lst = [1, 2, 4, 8, 'N', 'M', 128, 256, 512]
#Your code here
print(lst)
```
```python {.task_hint}
lst[4:6] = [16, 32, 64]
```

В этом списке последовательность букв английского алфавита прервана элементами - пустыми списками. Исправьте это при помощи присвоения слайсу.{.task_text}
```python {.task_source #python_chapter_0060_task_0070}
lst = ["A", "B", [], [], [], "D", "E", "F", "G", "H"]
#Your code here
print(lst)
```
```python {.task_hint}
lst[2:5] = ["C"]
```

Через присвоение слайсу пустого списка можно удалять произвольные последовательности элементов.

Удалите выбивающиеся из последовательности элементы. Используйте для этого присвоение слайсу. {.task_text}
```python {.task_source #python_chapter_0060_task_0080}
lst = ["A", None, 0, "B", "C", "D", "E"]
#Your code here
print(lst)
```
```python {.task_hint}
lst[1:3] = []
```

## Распространенные операции над списками
Операции, рассмотренные в прошлой главе применительно к строкам, применимы и к спискам. Среди них присваивание `=`, сравнивание `==`, проверка на вхождение элемента с помощью `in`, конкатенация (`+`, `+=`), повторение последовательности n-ное количество раз через умножение `* n`.

Так выглядит проверка, содержит ли список значение -1:
```python
if -1 in [8, -1, 93]:
    print("list contains -1")
```
```
list contains -1
```

А так выглядит умножение списка на число:
```python
lst = ["a", "b"]
print(lst * 4)
```
```
['a', 'b', 'a', 'b', 'a', 'b', 'a', 'b']
```

Добавьте элементы списка `m` в начало списка `l`. {.task_text}
```python {.task_source #python_chapter_0060_task_0090}
m = ["dart", "carbon"]
l = ["kotlin"]
# Your code here
print(l)
```
```python {.task_hint}
l = m + l
```

Реализуйте функцию `is_item_in_list()`, которая принимает 2 аргумента: список и некое значение. Функция должна проверить, содержится ли значение в списке, и в зависимости от этого вернуть `True` либо `False`. {.task_text}
```python {.task_source #python_chapter_0060_task_0100}

```
```python {.task_hint}
return item in lst
```

К спискам, как и к строкам, применимы функции: определение длины `len()`, поиск минимального и максимального элементов `min()` и `max()`.

Пример поиска минимального элемента:
```python
temperatures = [23.2, 21.0, 19.9, 22.5]
min_temp = min(temperatures)
print(min_temp)
```
```
9.9
```

Для удаления одного элемента или слайса элементов из списка используется **оператор del:**
```python
x = ["assert", "bool", "false"]
del x[1]
print(x)
```
В данном примере из списка был удален элемент по индексу 1:
```
['assert', 'false']
```

Используя оператор `del` для слайса, удалите из списка `words` все элементы кроме первого и последнего. {.task_text}

Выведите получившийся список в консоль. {.task_text}
```python {.task_source #python_chapter_0060_task_0110}
words = "Sparse is better than dense".split()
```
```python {.task_hint}
del words[1:-1]
```

## Распространенные методы списков
- `l.append(x)` — добавляет элемент `x` в конец списка `l`.
- `l.insert(i, x)` — добавляет к списку `l` по индексу `i` значение `x`.
- `l1.extend(l2)` — добавляет к списку `l1` элементы из итерабельного объекта `l2`.
- `l.remove(x)` — удаляет из списка `l` первое вхождение `x`. Если такое значение не найдено, кидает исключение `ValueError: list.remove(x): x not in list`.
- `l.pop(i=-1)` — удаляет из списка `l` элемент по индексу и возвращает его значение. `i` является необязательным параметром со значением -1 по умолчанию.
- `l.clear()` — удаляет из списка все элементы.
- `l.sort(key=None, reverse=False)` — сортирует список по возрастанию. Если `reverse` выставлен в `True`, то по убыванию. Если задан аргумент `key`, то для сравнения элементов при сортировке используется функция от одного аргумента, например `key=str.lower`.

Пример сортировки списка слов по убыванию их длины:
```python
words = ["clear", "pop", "append"]
words.sort(key=len, reverse=True)
print(words)
```
```
['append', 'clear', 'pop']
```

Как считаете, что выведет этот код?
```python
res = ["Errors", "should", "never", "pass"]
res += "silently"
print(res)
```

При конкатенации списка с неким объектом интерпретатор неявно пытается применить конструктор `list()` к данному объекту. А как мы помним, на вход `list()` принимает итерабельный объект. В нашем случае это строка "silently". Поэтому результат выглядит так:
```
['Errors', 'should', 'never', 'pass', 's', 'i', 'l', 'e', 'n', 't', 'l', 'y']
```

Исправьте этот код, чтобы на 2-ой строке к списку добавлялась полноценная строка. {.task_text}
```python {.task_source #python_chapter_0060_task_0120}
res = ["Errors", "should", "never", "pass"]
res += "silently" # Fix me
print(res)
```
```python {.task_hint}
res.append("silently")
```

Составьте из элементов списка `words` строку `citation`. Слова в строке должны быть разделены пробелом. Для этого воспользуйтесь методом строки `join()`, рассмотренным в прошлой главе. Выведите строку в консоль. {.task_text}
```python {.task_source #python_chapter_0060_task_0130}
words = ["simple", "is", "better", "than", "complex"]
```
```python {.task_hint}
citation = " ".join(words)
```

Реализуйте функцию `abs_sort`, которая принимает на вход список чисел и сортирует его по убыванию модуля числа. {.task_text}
```python {.task_source #python_chapter_0060_task_0140}
```
```python {.task_hint}
l.sort(key=abs, reverse=True)
```

## Как организован список изнутри
В недрах интерпретатора CPython тип `list` — это массив динамической длины, а не связный список, как можно было бы предположить. Данный массив состоит из элементов, аллоцированных друг за другом в единой выделенной под них области памяти. Каждый элемент массива хранит ссылку на область памяти, содержащую нужный объект. Интерпретатор хранит указатель на первый элемент массива и длину массива.

Исходя из этого, можно сделать выводы об алгоритмической сложности манипуляций над объектами типа `list`. Например, операция `l.pop(0)` имеет сложность O(n): она удаляет нулевой элемент и сдвигает оставшиеся элементы массива на 1. В то же время операция `l.append(x)` имеет амортизированную сложность O(1): если в выделенной области памяти хватает места, новый элемент добавляется в массив за константное время. Если же места под элемент не хватает, осуществляется аллокация новой более обширной области памяти, в которую переносятся все элементы из старой.

## Кортежи и их отличия от списков
Кортеж (tuple) — это неизменяемый список. К нему применимо подмножество не модифицирующих операций над списком. Создается кортеж двумя способами.

Через круглые скобки:
```python
langs = ("haskell", "erlang", "scala")
```

С помощью конструктора, в который передается итерабельный объект (в данном примере — список):
```python
lst = [1, 2, 3]
tpl = tuple(lst)
```

Варианты объявления пустого кортежа:
```python
t1 = ()
t2 = tuple()

print(type(t1), type(t2))
```

Консольный вывод подтверждает, что объектам `t1` и `t2` интерпретатором корректно присвоен тип `tuple`:
```
<class 'tuple'> <class 'tuple'>
```

Нюансы начинаются, когда нам требуется завести кортеж, состоящий из одного элемента. Как считаете, что выведет этот код?
```python
tpl = (128)
print(type(tpl))
```

Как ни странно, интерпретатор принимает `tpl` за целое число:
```
<class 'int'>
```

Дело в том, что в питоне круглые скобки `()` зарезервированы не только для конструирования кортежа, но и для расстановки приоритета в математических операциях. Например:
```python
avg = (5.6 + 8.1) / 2.0
```

Выход есть! Чтобы завести кортеж из единственного элемента, достаточно поставить после элемента запятую:
```python
tpl = (128,)
print(type(tpl))
print(tpl)
```

Эта запятая заставляет интерпретатор правильно определить тип `tuple`. Обратите внимание, что запятая присутствует даже при консольном выводе кортежа, состоящего из одного элемента:
```
<class 'tuple'>
(128,)
```

## Неизменяемость кортежа и ее взлом
В предыдущих главах мы обсудили, что оператор `==` сравнивает содержимое объектов. А ключевое слово `is` проверяет, являются ли два объекта одним и тем же объектом в памяти. Как считаете, что выведет этот код?
```python
l1 = [1, 2]
l2 = [1, 2]

t1 = (1, 2)
t2 = (1, 2) 

print("l1 eq l2", l1 == l2)
print("l1 is l2", l1 is l2)

print("t1 eq t2", t1 == t2)
print("t1 is t2", t1 is t2)
```

Оператор `==` вернет `True` и для списка, и для кортежа. А вот `is` вернет `True` только для кортежа: значит, у `t1` и `t2` одинаковый адрес в памяти.
```
l1 eq l2 True
l1 is l2 False
t1 eq t2 True
t1 is t2 True
```

Причина — в неизменяемости кортежа. Интерпретатор видит, что содержимое кортежей совпадает, а раз оно не может быть модифицировано, то нет смысла дважды выделять память под одни и те же данные.

Являтся ли неизменяемость кортежа нерушимой инвариантой или ее можно случайно "сломать"? Удаление и добавление элементов кортежи не поддерживают. Попытка изменения элемента по индексу ведет к исключению:
```python
t = (5, 10, 20)
t[1] = 100
```

```
TypeError: 'tuple' object does not support item assignment
```

...Однако если один из элементов кортежа относится к изменяемым типам, то его, внимание, можно модифицировать! Например, если элемент — это список, интерпретатор не воспрепятствует добавлению в него элемента.

Проведите опыт: заведите два кортежа `t1` и `t2` с одинаковым содержимым `(1, [], 2)`. Выведите в консоль на двух разных строках проверку на поэлементное равенство и на совпадение объектов в памяти. {.task_text}

Добавьте в список, содержащийся в кортеже `t1`, элемент со значением "A". Повторите консольный вывод двух проверок на равенство. {.task_text}
```python {.task_source #python_chapter_0060_task_0150}
```
```python {.task_hint}
t1 = (1, [], 2)
```

О чем говорит консольный вывод задачи? 

Во-первых, он подтверждает цитату из заголовка главы: питон — это эксперимент по определению степени свободы разработчика ;) 

Мы убедились, что содержимое кортежа все-таки можно изменить (на длине кортежа это конечно не отразится). Главное, чтобы тип элемента кортежа этому способствовал. 

Во-вторых, если в двух казалось бы одинаковых кортежах содержатся элементы изменяемых типов, то интерпретатор уже не будет хранить эти кортежи по общему адресу (`is` для них вернет `False`). 

## Диапазоны
Диапазон (range) — это неизменяемая последовательность чисел, удобная для заполнения или прохода по другим коллекциям, а также для итерирования в цикле `for`:
```python
for i in range(5):
    print(i)
```
В данном случае счетчик `i` на каждом из витков цикла последовательно принимает значения от 0 до 4.

Из трех параметров конструктора диапазона только один является обязательным: 
`range(start = 0, stop, step = 1)`
- `start` — начальное значение диапазона, 
- `stop` — финальное значение **не включительно,**
- `step` — шаг инкремента для получения следующего числа из диапазона.

С помощью диапазона в цикле `for` выведите в консоль значения от 8 до 0 включительно через 1: 8, 6 и тд. {.task_text}
```python {.task_source #python_chapter_0060_task_0160}
```
```python {.task_hint}
for i in range(8, -1, -2)
```

Так как диапазон — итерируемый объект, его можно передавать в конструктор `list()`.

Создайте список из диапазона от 10 до 14 включительно и выведите его на экран. {.task_text}
```python {.task_source #python_chapter_0060_task_0170}
```
```python {.task_hint}
print(list(range(10, 15)))
```

У диапазона есть важное **преимущество** перед списками и кортежами: он занимает в памяти небольшое фиксированное пространство. Вне зависимости от количества чисел, входящих в диапазон. Размер списка или кортежа, напротив, растет с ростом количества элементов. 

Дело в том, что диапазон хранит только значения для `start`, `stop`, `step`, а очередное значение вычисляет по необходимости (например, при переходе на следующий шаг цикла). Это означает, что значения диапазона нельзя "отмотать" назад или обратиться к ним по индексу.

## Резюмируем
- Тип `list` (список) — это гетерогенная последовательность элементов с доступом по индексу.
- Для создания списка используются квадратные скобки `[]` либо конструктор `list()`.
- Тип `tuple` (кортеж) — это неизменяемый список, хотя у иммутабельности есть исключение: если в кортеже хранится элемент изменяемого типа (например, список), то этот элемент можно модифицировать.
- Для создания кортежа используются круглые скобки `()` либо конструктор `tuple()`.
- При создании кортежа, содержащего единственный элемент, не забывайте после элемента указывать запятую: `t = (8,)`.
- Тип `range` (диапазон) — неизменяемая последовательность без доступа по индексу. Фактически это арифметическая прогрессия целых чисел.
