# Глава 2. Синтаксис
> Правила для всех одинаковы, только исключения разные.  
Данил Рудый

Не глава, а настоящий трамплин в мир питона. Здесь описаны базовые правила и синтаксические конструкции языка. Вы научитесь не только читать скрипты на питоне, но и писать свои собственные.

{.paragraph}

## Структура программы
В C# точкой входа в приложение является метод `Main()`. В Java и go — `main()`. Эти и многие другие языки объединяет нерушимое правило: нельзя просто написать код на уровне файла и запустить его. Питон — представитель скриптовых языков, и на него это правило не распространяется: с первой же строчки скрипта может начинаться бизнес-логика, не обернутая ни в какую функцию.

Исходный код программы на питоне принято сохранять в файлах с расширением `.py`. Для запуска из консоли необходимо вызвать интерпретатор питона и первым аргументом указать имя файла. Допустим, исходный код в `example.py` состоит из одной строчки:
```python
print("Dummy script, does nothing")
```

Тогда после запуска скрипта мы увидим в консоли ожидаемый вывод:
```shell
$ python example.py
Dummy script, does nothing
```

В этом коротком примере вся программа сводится к вызову функции вывода текста. В ней нет подключения модулей, объявления переменных, классов, функций. Что ж, усложним код. 

{.paragraph}

Пусть в консоль печатается текущее время:
```python
from datetime import datetime

def print_time():
    now = datetime.now()
    current_time = now.strftime("%H:%M:%S")
    print("Current Time:", current_time)

print_time()
```

На первой строке из модуля `datetime` импортируется одноименный объект в глобальное пространство имен программы. Затем объявляется функция `print_time()`. Внутри нее у объекта `datetime` вызывается метод `now()` для получения текущего времени; оно преобразовывается в удобный формат и печатается в консоль. На последней строке объявленная функция `print_time()` вызывается.

Пример демонстрирует общепринятую практику по **структурированию кода:** в начале файла импортируются нужные модули, затем объявляются какие-то глобальные переменные, функции и другие полезности, а в самом конце все это используется.

{.paragraph}

## Синтаксические правила
С этих правил начинают свой путь все питонисты.

**Вложенные блоки кода** отделяются отступами, а не фигурными скобками. Мы будем придерживаться правила из PEP8: 1 отступ = 4 пробела. 
Вложенному блоку предшествует инструкция, заканчивающаяся двоеточием. Перед телом цикла — это условие цикла. Перед телом `if` — условие `if`. И так далее.

{.paragraph}

Пример условия:
```python
if user_is_active:
    get_next_command()
else:
    close_session()
```

{.paragraph}

Пример цикла:
```python
for item in items:
    process(item)
```

{.paragraph}

Пример функции:
```python
def is_long(s):
    if len(s) > 79:
        return True
    return False
```

Конец строки — это конец инструкции. Точка с запятой в конце не ставится.

{.paragraph}

Пример с последоательным вызовом двух пользовательских функций. Никаких точек с запятой:
```python
check_db_is_online()
start_transaction()
```

{.paragraph}

Инициализируйте две переменные:{.task_text}
- `a`, равную 8, на одной строке.
- `b`, равную 10, на другой.
```python {.task_source #python_chapter_0020_task_0010}
```
```python {.task_hint}
Синтаксис: перемення = значение
```

{.paragraph}

Исправьте синтаксические ошибки в коде:{.task_text}
```python  {.task_source #python_chapter_0020_task_0020}
for i in range(1, 10); print(i);
```
```python {.task_hint}
Нужно удалить точку с запятой и перенести вызов print() на новую строку с отступом.
```

{.paragraph}

Если инструкция не влезает в строку (например, становится длиннее рекомендованных PEP8 79 символов), ее можно разбить на несколько строк с использованием круглых скобок. 
Было:
```python
while retries_count < max_retries and service_is_up and not cancelled:
    send_request()
```

Стало:
```python
while (retries_count < max_retries and 
       service_is_up and not cancelled):
    send_request()
```

{.paragraph}

Разбейте условие `if` на две строки:{.task_text}
```python  {.task_source #python_chapter_0020_task_0030}
MAX_SESSIONS = 5
MAX_QUEUE_LEN = 100

sessions_count = 9
queue_tasks = ["task1", "task2"] # Here we create list of strings

if sessions_count > MAX_SESSIONS or len(queue_tasks) > MAX_QUEUE_LEN:
    print("Error handling request")
```
```python {.task_hint}
Не забудьте обернуть условие в круглые скобки.
```

{.paragraph}

## Исключения из правил
Из этих несложных правил есть и исключения. Но их лучше избегать, чтобы не снижать читаемость кода. Тем не менее, вы можете натолкнуться на злоупотребление ими в чужом коде.

Например, несколько простых инструкций в одной строке не являются ошибкой. Друг от друга они отделяются точкой с запятой. В этом примере переменным `x` и `y` присваиваются результаты пользовательских функций:
```python
x = x_offset(); y = y_offset(); print(x, y)
```

Сделайте этот код более читабельным. Одна строка — одна инструкция: {.task_text}
```python  {.task_source #python_chapter_0020_task_0040}
x = 5; y = 8; print(x, y)
```
```python {.task_hint}
Должно получиться 3 строки: 2 для инициализации переменных и 1 на вызов функции.
```

{.paragraph}

Также допустимо размещать инструкцию и ее вложенный блок на одной строке. Это сработает, если вложенный блок не содержит каких-то своих вложенных инструкций:
```python
while is_acitve: send_request()
```

{.paragraph}

Перепишите этот код, чтобы вложенный блок `while` шел на отдельной строке: {.task_text}
```python  {.task_source #python_chapter_0020_task_0050}
def send_request():
    # some business logic
    return False

is_active = True

while is_active: is_active = send_request()
```
```python {.task_hint}
Тело цикла должно идти на отдельной строке с отступом.
```

{.paragraph}

## Объявление переменных
При объявлении переменной тип не указывается:
```python
height = 1.78
```

Но бывают случаи, когда нужно завести переменную и инициализировать значением по умолчанию. Для этого после оператора присвоения вызывается конструктор типа:
```python
height = float()
print(height)
```

В данном примере `height` будет равен 0.0. Это дефолтное значение для `float`. Дефолтными значениями для целого, булевой переменной и какого-либо контейнера будут соответственно 0, `False` и пустой контейнер.
В большинстве случаев явный вызов конструктора используется не для простых типов данных, а для списков (list), словарей (dict) и множеств (set). Например, `user_names = set()`.

{.paragraph}

А как быть с **константами?** В питоне их нет! Вместо констант — соглашение код-стайла: переменные, предназначенные только для чтения, именовать заглавными буквами:
```python
HEIGHT = 1.78
WIDTH = 0.5
```

Чисто технически ничто не остановит программиста от модификации такой переменной. Сохраняйте бдительность!

{.paragraph}

Заведите константу `API_URL`, равную строке "https://api.senjun.dev.ru": {.task_text}
```python  {.task_source #python_chapter_0020_task_0060}
```
```python {.task_hint}
API_URL = "https://api.senjun.dev.ru"
```

{.paragraph}

В питоне есть объект-синглтон, представляющий собой **неименованную переменную.** Работать с ним можно через символ `_`. Например, так выглядит использование неименованной переменной для пропуска второго из двух значений, возвращаемых функцией:
```python
res, _ = get_val_and_flag()
```

{.paragraph}

## Комментарии
Комментарии в питоне могут быть однострочными. Они начинаются с символа `#`:
```python
# TODO: refactor coords calculation
x = x_offset() # get x offset
```
...И многострочными. Такие комментарии обрамляются тройными кавычками:
```python
def get_coords():
    """Here we calculate x, y and transform
    these coordinates to lat, lon"""
    pass
```

{.paragraph}

## Условие if/elif/else
Синтаксис условных выражений в питоне ничем принципиально не отличается от других языков:
```python
if data_is_loaded:
    process_data()
elif session_is_open():
    check_data()
elif data_is_corrupted():
    retry()
else:
    wait(timeout)
```

Блоки `elif` и `else` не обязательны, а `elif` можно повторять сколько угодно раз. Фактически `if/elif` — это замена популярной конструкции `switch/case` в других языках.

{.paragraph}

Сделайте этот код более читабельным, уменьшив вложенность условий: откажитесь от вложенных `if` в пользу единого блока `if/elif/else`. {.task_text}
```python {.task_source #python_chapter_0020_task_0070}
def analyze_string(s):
    print("Analyzing string...")

    if s.isdigit():
        print("All characters are digits")
    else:
        if s.islower():
            print("All characters are lower case")
        else:
            if s.isalpha():
                print("All characters are in the alphabet")
            else:
                print("There is nothing special about this string")
    
    print("Finished string analysis")


analyze_string("Hint")
```
```python {.task_hint}
Должно получиться условие, состоящее из 1 if, 2 elif и 1 else.
```

{.paragraph}

## Тернарный if
Условие `if/else` можно записать более компактно, используя тернарный опертор:
```python
res = "OK" if code == 200 else "Error"
```
Этот пример трактуется так: присвоить переменной `res` значение "OK", если `code` равен 200. Иначе присвоить `res` значение "Error".

{.paragraph}

На строке 2 напишите тернарный оператор, присваивающий переменной `s_descr` значение "long string", если `s` длиннее 79 символов, и "short string", если это не так. Для определения длины строки используйте встроенную функцию `len()`. Аргументом `len()` является строка.  {.task_text}
```python {.task_source #python_chapter_0020_task_0080}
s = "Explicit is better than implicit."

```
```python {.task_hint}
s_descr = "long string" if len(s) > 79 else "short string"
```

{.paragraph}

Замените `if/else` на тернарный оператор:  {.task_text}
```python {.task_source #python_chapter_0020_task_0090}
for val in [8, 3, 16]:
    if val % 2 == 0:
        res = "even"
    else:
        res = "odd"

    print(val, res)
```
```python {.task_hint}
res = "even" if val % 2 == 0 else "odd"
```

{.paragraph}

## Циклы for и while
Цикл `while` — это всем известный классический `while` из JavaScript, C++, Java:
```python
x = 100

while x > 0:
    handle(x)
    x -= 1
```

Вариация вечного цикла:
```python
while True:
    rotate_spinner()
```

Этот цикл тоже является вечным, потому что 1 интерпретируется как "истина":
```python
while 1:
    run()
```

{.paragraph}

Цикл `for` последовательно перебирает элементы коллекции:
```python
for resp in responses:
    parse(resp)
```

Пример прохода в цикле `for` по последовательности чисел, которую генерирует функция `range()`:
```python
for x in range(0, 10):
    print(x * x)
```

Последовательность состоит из целых от 0 до 9, 10 в нее не попадает.

{.paragraph}

Имплементируйте тело функции. Пусть она возвращает количество слов, из которых состоит строка `s` в snake_case. Например, если на вход функции прилетает `s`, равная "not_supported_format", функция вернет 3. А для "naive_solution" вернет 2.   {.task_text}
```python  {.task_source #python_chapter_0020_task_0100}
def get_words_count(s):
    # Your code here
```
```python {.task_hint}
Можно пройтись циклом по строке и посчитать в ней количество символов '_'. На основании этого сделать вывод о количестве слов, которые '_' разделяет.
```

{.paragraph}

В питоне есть оператор `continue` для перехода на следующую итерацию цикла.
В этом цикле выведутся все согласные буквы:
```python
s = "Now is better than never."

for letter in s:
    if letter in "aeiouy":
        continue

    print(letter)
```

Также в питоне есть оператор `break` для выхода из цикла. Этот цикл завершится на первом встреченном пробеле:
```python
s = "Although never is often better than right now."

for letter in s:
    if letter == " ":
        break

    print(letter)
```

{.paragraph}

Забавная особенность питона: ключевое слово `else` может использоваться не только в связке с `if`, но и после циклов `while` и `for`! В таком случае `else` сработает, только если выход из цикла произошел **без** участия `break`. 

```python
s = "If the implementation is hard to explain, it's a bad idea."

for letter in s:
    if letter == "y":
        break

    print(letter)
else:
    print("There is no letter 'y' in string")
```
В данном примере в консоль будет выведен текст из блока `else`. Потому что из цикла `for` не было выхода по `break`.

{.paragraph}

Имплементируйте функцию `print_letters()`. На вход она принимает строку. Функция анализирует каждую букву строки:{.task_text}
- Если в строке содержится заглавная буква, то печатает ее. Для определения, что буква заглавная, используйте метод `isupper()`.
- Если строчная — пропускает.
- Если найден пробел, то все следующие за ним символы пропускаются.
- Если в строке не было ни одного пробела, функция печатает "no spaces".
 {.task_text}
```python {.task_source #python_chapter_0020_task_0110}
def print_letters(s):
    # Your code here
```
```python {.task_hint}
Для выхода из цикла используйте 'break', для перехода на новую итерацию — 'continue', а для обработки условия не выхода по 'break' — 'else'.
```

{.paragraph}

## Оператор pass
Бывают случаи, когда вложенный блок требуется оставить пустым. Например, чтобы дописать его в следующем пул-реквесте. Допустим, нам нужно обработать ветку `if`, а в `else` оставить комментарий "Handle this case" без кода:
```python
if found_match(query):
    handle(query)
else:
    # TODO: handle this case
```
Но пустой вложенный блок — это синтаксическая ошибка:
```
SyntaxError: unexpected EOF while parsing
```

Чтобы ее избежать, был придуман оператор `pass`. `pass` — это ассемблеровский NOP в мире питона. Так сказать оператор "отсутствие оператора". 

Теперь синтаксической ошибки не будет:
```python
if found_match(query):
    handle(query)
else:
    # TODO: handle this case
    pass
```

{.paragraph}

Добавьте `pass` в цикл, чтобы устранить ошибку интерпретатора:{.task_text}
```python {.task_source #python_chapter_0020_task_0120}
n = 101

while n < 100:
```
```python {.task_hint}
```

{.paragraph}

## Резюмируем
- Блоки кода определяются двоеточием и отступами.
- Варианты объявления переменной: `x = 0`, `x = int()`.
- Символ `_` обозначает неименованную переменную.
- Констант в питоне нет. Но есть джентльменское соглашение именовать предназначенные только для чтения переменные большими буквами: `TARGET_PATH="/tmp/data"`.
- Однострочные комментарии начинаются с символа `#`, многострочные — заключаются в тройные кавычки: `"""TODO: fix this."""`.
- Для условного выполнения кода есть конструкции `if/elif/else` и тернарный `if`.
- В питоне есть два вида циклов: `for` и `while`. 
- Циклы поддерживают операторы `break`, `continue` и `else`. `else` срабатывает, если из цикла не было выхода по  `break`.
- Для обозначения отсутствия операции во вложенном блоке предусмотрен оператор `pass`.

{.paragraph}
