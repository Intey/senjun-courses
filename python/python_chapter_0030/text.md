# Глава 3. Функции
> Функции, которые производят значения, легче комбинировать новыми способами, чем те, которые производят сайд-эффекты.  
Марейн Хавербеке

Синтаксис функций — показательная иллюстрация того, что питон заточен на разработку емкого и не отягощенного синтаксическими излишествами кода. В этой главе мы разберем, как функции объявляются и вызываются, для чего нужны вложенные функции и стоит ли злоупотреблять лямбдами.

## Объявление и вызов
Если вас интересует, как в питоне выглядит самая короткая функция, то вот она:
```python
def f():
    pass
```

Этот код практически бесполезен, зато демонстрирует минимальное объявление функции: ключевое слово `def`, имя функции и круглые скобки, в которых перечисляются параметры. Так как `f()` не принимает параметров, то скобки пусты. Затем идет блок с отступом — тело функции. И да, если функция состоит из единственного выражения, то разрешается оставить его на той же строке, что и имя:
```python
def f(): pass
```

А вот и вызов функции:
```python
f()
```

В отличие от C++, **в питоне нет перегрузки функций** — возможности создания нескольких функций с одним именем, но отличающихся типами параметров или их количеством. Дело в том, что выбор конкретной функции происходит на этапе компиляции. А питон к компилируемым языкам не относится, поэтому и не поддерживает перегрузку.

## Docstring
Если функция не сводится к совсем уж тривиальным действиям, считается хорошим тоном оставлять в ней краткий комментарий с описанием. Он называется **docstring** и располагается на первой строчке тела функции:
```python
def f():
    """This function does completely nothing"""
    pass
```

IDE, умеющие работать с питоном, используют docstring для подсказок разработчику. В некоторых случаях имеет смысл писать развернутые многострочные комментарии:
```python
def fetch_records(table, ids):
    """Selects records from the table which correspond to ids.

    Args:
        table: name of the table in th database.
        ids: A sequence of integers representing the id of each record
            to fetch.

    Returns:
        A dict mapping id to the corresponding record in table.
    """
    pass
```
Но лучше стремиться к краткости. Следуйте совету Марка Цукерберга — комментарии в коде должны быть похожими на кружевные трусики: маленькими, прозрачными, но оставляющими достаточно места для воображения.

Заведите функцию `print_sum()`, которая принимает 2 числа и выводит в консоль их сумму. Добавьте в функцию docstring. Вызовите получившуюся функцию, передав в нее 3 и 8. {.task_text}
```python {.task_source #python_chapter_0030_task_0010}
```
```python {.task_hint}
После определения функции не забудьте ее вызвать с аргументами, указанными в задаче.
```

## Параметры и аргументы функции
Напомним, что параметр — это имя, фигурирующее в определении функции. Он получает конкретное значение при вызове функции. А аргумент — это фактическое значение, переданное функции при вызове.

Следующий пример демонстрирует объявление и использование функции `count_vowels()`. Она принимает два параметра: `s` — строку, в которой требуется посчитать количество гласных букв, и `n` — длину строки. Причем параметр `n` является опциональным и по умолчанию выставляется в `None` — объект, означающий отсутствие значения. Для определения, относится ли буква к гласным, заведена вспомогательная функция `is_vowel()`.

```python
def is_vowel(c):
    return c.lower() in ['a', 'e', 'i', 'o', 'u', 'y']


def count_vowels(s, n = None):
    if n is None:
        n = len(s)

    if n == 1:
        return is_vowel(s[n - 1])

    return count_vowels(s, n - 1) + is_vowel(s[n - 1])
```

Разумеется, подсчет гласных букв можно (и нужно) реализовать на питоне гораздо, гораздо проще — он уместится в одну строку. Зато этот перемудреный пример показывает рекурсивный вызов функции, использование вспомогательной функции и обращение к символу строки по индексу (через квадратные скобки `[]`).

## Позиционные и именованные аргументы
В питоне есть две категории аргументов: позиционные и именованные.

**Позиционные аргументы** передаются в функцию в строгой очередности (которая указана в объявлении функции). Позиционные аргументы идут без указания имен:
```python
res = count_vowels("Some string", None)
```

```python
text = "It's a recursion example!"
text_len = len(text)

res = count_vowels(text, text_len)
```

Если у параметра указано значение по умолчанию, то его разрешается опустить при вызове:
```python
res = count_vowels("python")
```

**Именованные аргументы** передаются в функцию с указанием конкретного имени, к которому привязывается значение:
```python
res = count_vowels(s = "Some string", n = None)
```

```python
res = count_vowels(s = "python")
```

При вызове в функцию можно передавать и позиционные, и именованные аргументы. Главное — не смешивать их в кучу: позиционные аргументы идут в начале, и только после них следуют именованные. 

Представим функцию, принимающую 4 параметра:
```python
def f(a, b, c, d):
    pass
```

Вызов этой функции с передачей вначале двух позиционных, а затем двух именованных аргументов, отработает корректно:
```python
f(1, 2, c = 3, d = 4)
```

Чередование же позиционных и именованных аргументов приведет к ошибке:
```python
f(a = 1, 2, c = 3, d = 4)
```

На данной строчке сгенерируется исключение `SyntaxError: positional argument follows keyword argument`.

Найдите и исправьте все некорректные вызовы функции `print_file_extension()`. Внутри этой функции вызывается метод строки `split()`, по разделителю `delimiter` превращающий строку в список подстрок. Из получившегося списка на экран выводится последний элемент (обращение по индексу -1 к списку означает взятие последнего элемента). {.task_text}
```python {.task_source #python_chapter_0030_task_0020}
def print_last_item(s, delimiter):
    print(s.split(delimiter)[-1])

# File extension
print_last_item(s="/var/log/msg.log")

# The last word in the sentence
print_last_item("Complex is better than complicated", " ")

# Child directory
print_last_item("/home/george/Documents/2023/August", delimiter="/")
```
```python {.task_hint}
Обратите внимание на комментарии в коде.
```

## Передача аргументов по ссылке и по значению
Аргументы могут передаваться в функцию как по ссылке, так и по значению. Но это определяется не при объявлении или вызове функции, а зависит от типа передаваемого объекта.

Что это значит? Все объекты в питоне делятся на изменяемые и не изменяемые. Более подробно мы раскроем эту тему в следующей главе. А пока скажем, что к неизменяемым объектам относятся например числа, строки, кортежи. Они называются неизменяемыми, потому что при каждой модификации объекта у него меняется id. Id — обязательный атрибут всех объектов, он есть даже у чисел. Изменение id фактически означает, что объект перестает существовать и на его месте появляется новый. 

А изменяемые объекты — это списки, словари и так далее. При модификации объектов этих типов их id не меняется.

Отсюда **правило:** неизменяемые объекты всегда передаются в функцию по значению, изменяемые — по ссылке. 

Это правило — популярнейшая причина ошибок начинающих питонистов. Сколько часов из-за него было потрачено на дебаг, сколько клавиатур разбито... Не наступайте на эти грабли. Помните: если внутри функции вы модифицируете аргумент-число, эти изменения не покинут пределов функции. И наоборот, если передаете в функцию список, четко понимайте, что все изменения в этом списке сохранятся после выхода из функции.

## Оператор return
Функция может принимать произвольное количество аргументов или не принимать их вовсе. А что насчет возвращаемого значения? Аналогично: функция может возвращать произвольное количество значений или не возвращать ничего. Возвращаемые значения указываются после оператора `return` и перечисляются через запятую.

Возвращение двух значений на примере расчета площади круга и длины окружности по радиусу `r`:
```python
import math

def get_circle_info(r):
    return math.pi * r * r, math.pi * 2.0 * r

area, circumference = get_circle_info(r=5.2)
```

Вызов `return` для нескольких значений на самом деле неявно оборачивает их в **кортеж** — неизменяемый вариант массива, который мы рассмотрим позже. А присвоение в переменные нескольких значений, полученных из функции — всего лишь синтаксический сахар над распаковкой кортежа. Для создания кортежа используются круглые скобки: `()`. 

Эти два варианта вызова `return` являются эквивалентными:
```python
return s, r
```

```python
return (s, r)
```

Напишите функцию `triangle_area(b, h)`, принимающую длину основания треугольника и его высоту. По ним функция должна вернуть площадь треугольника. Формула простая: половина произведения основания на высоту. Например, `triangle_area(b=4, h=8)` равен 16. {.task_text}
```python {.task_source #python_chapter_0030_task_0030}
```
```python {.task_hint}
0.5 * b * h
```

Если функция ничего не возвращает, писать в конце `return` не обязательно:
```python
import pickle

def serialize_data_to_file(data, filepath):
    pickle.dump(data, open(filepath, "wb"))
``` 

В этом примере мы подключаем модуль `pickle` для сериализации и десериализации объектов питона в поток байтов. Функция `serialize_data_to_file` - всего лишь обертка для превращения произвольных данных в поток байтов и сохранения его в интересующий файл. Так как функция ничего не возвращает, `return` в ней отсутствует.

Функция, внутри которой есть `return`, но без возвращаемого значения, либо в которой `return` вовсе отсутствует, на самом деле неявно возвращает `None`. `None` — специальный объект, означающий отсутствие значения:

```python
res = serialize_data_to_file(user_stats, "/tmp/stats_latest")
print(res)
```

Консольный вывод после запуска этого кода выглядит так:
```
None
```

## Вложенные функции
В питоне функции могут быть вложенными (inner, nested), то есть объявленными внутри другой функции:
```python
def outer_f():
    def inner_f():
        print("This is inner function")
    
    inner_f()

outer_f()
inner_f()
```

В данном примере вызов `outer_f()` завершится успешно, а вызов `inner_f()` строчкой ниже приведет к исключению:
```
NameError: name 'inner_f' is not defined
```

Пример показывает, что вложенные функции скрыты от от внешнего доступа. Таким образом достигается инкапсуляция вспомогательного кода: он исключается из глобальной области видимости.

Итак, вложенные функции нельзя вызывать извне. Но сами они имеют доступ к аргументам и локальным переменным функции-обертки!
```python
def count_vowels(s, n = None):
    def is_vowel():
        return s[n - 1].lower() in ['a', 'e', 'i', 'o', 'u']

    if n is None:
        n = len(s)
    
    if n == 1:
        return is_vowel()

    return count_vowels(s, n - 1) + is_vowel()
```

В этом примере вложенная функция `is_vowel()` работает с параметрами `s` и `n`. Мы видим, что вложенная функция имеет доступ к параметрам и переменным внешней функции. Это знание нам пригодится, когда в следующих главах мы будем обсуждать **замыкания** (closures) — вложенные функции, которые ссылаются на переменные, объявленные в теле внешней функции.

Напишите функцию `calc_gcd(a, b)`, которая находит наибольший общий делитель (GCD, greatest common divisor) чисел `a` и `b`. Функция должна быть рекурсивной и возвращать два значения: GCD и количество рекурсивных вызовов, которые были выполнены перед возвратом ответа. {.task_text}

Например, `calc_gcd(25, 15)` вернет 5 и 4, а `calc_gcd(8, 3)` вернет 1 и 5.  {.task_text}

Для подсчета количества рекурсивных вызовов заведите вложенную функцию. В своем решении реализуйте алгоритм Евклида. Он заключается в следующем: {.task_text}
- GCD равен `a`, если `a` и `b` совпадают.
- GCD равен `calc_gcd(a - b, b)`, если `a` больше `b`.
- GCD равен `calc_gcd(a, b - a)`, если `a` меньше `b`.

```python {.task_source #python_chapter_0030_task_0040}
```
```python {.task_hint}
Вложенная функция на вход может принимать счетчик вызовов, инкрементировать его и возвращать в качестве одного из значений в return.
```

Кстати, автор питона Гвидо ван Россум в своей известной презентации "Introduction to Python" предложил вот такой лаконичный вариант поиска наибольшего общего делителя:
```python
def gcd(a, b):
    "greatest common divisor"
    while a != 0:
        a, b = b % a, a # parallel assignment
    return b
```
В примере от Гвидо применяется мощный инструмент питона: parallel assignment.

```python
a = x
b = y
```

Это прием, позволяющий запись выше сократить до одной строки:
```python
a, b = x, y
```

Parallel assignment особенно популярен, когда требуется выполнить swap — поменять значения двух переменных:
```python
x, y = y, x
```

## Лямбда-функции
Лямбда-функции (их также называют анонимными) — это компактные функции-однострочники. Они могут иметь много параметров, но только одно вычисляемое значение, для которого не указывается `return`. 

Синтаксис объявления лямбда функции:
```
lambda параметры : выражение
```

Пример объявления и вызова лямбда-функции, которая повторяет строку `s` `n` раз:
```python
mult_str = lambda s, n:  s * n
print(mult_str("*", 5))
```

Здесь функциональному объекту `mult_str` присваивается безымянная лямбда-функция. На следующей строке функциональный объект вызывается, и в консоли появляется вывод:
```
*****
```

Эта лямбда-функция эквивалентна обычной функции, просто позволяет сэкономить немного места:
```python
def mult_str(s, n):
    return s * n
```

Вместо присваивания лямбды функциональному объекту ее можно сразу вызвать.
```python
(lambda s, n:  s * n)("I", 3)
```

Код выглядит странно, но выводит в консоль ожидаемый результат:
```
III
```

Напишите лямбда-функцию, которая принимает два числа `a` и `b`, возвращает их сумму и разность. Присвойте ее функциональному объекту `calc`. {.task_text}

Чтобы лямбда корректно вернула пару значений, явным образом положите их в кортеж: оберните возвращаемые значения в круглые скобки, необходимые для конструирования кортежа. {.task_text}
```python  {.task_source #python_chapter_0030_task_0050}
```
```python {.task_hint}
calc = lambda a, b: (a + b, a - b)
```

Напишите лямбда-функцию, которая просто выводит в консоль "Press any key to continue". Присвойте ее функциональному объекту `to_next_step`.  {.task_text}

Вызовите этот объект.  {.task_text}

```python  {.task_source #python_chapter_0030_task_0060}
```
```python {.task_hint}
to_next_step = lambda : print("Press any key to continue")
```

Теперь вы узнаете лямбду, если увидите ее в чужом коде! Но стоит ли лямбдами злоупотреблять? В PEP8 сказано следующее: всегда используйте определение функций через `def` вместо того, чтобы присваивать лямбду функциональному объекту. PEP8 настаивает на тотальном избегании лямбд, такие дела.

Например, вот эту лямбду
```python
f = lambda x: 2 * x
```
PEP8 считает нужным превратить в полноценную функцию:
```python
def f(x): return 2 * x
```

С чем это связано? Да, лямбды действительно позволяют сэкономить немного места. Но взамен лишают вас понятного колстека, усложняют дебаг. Потому что в трейсбэк вместо имени конкретной функции попадает весьма расплывчатое `<lambda>`. Так что выбирая между компактностью и понятностью, отдавайте предпочтение понятности.

## Вариативные функции
Вариативные функции (variadic funcions) — это функции с переменным числом аргументов. Они реализованы в питоне и способны принимать произвольное количество позиционных и именованных аргументов:
```python
def f(*args, **kwargs):
    pass

f(1, 2, 3, k1="A", k2="B")
```

`args` и `kwargs` — популярные, но не обязательные имена для вариативных позиционных и именованных аргументов. Символы звездочек `*` и `**` перед аргументами означают, что внутри переменной содержится некоторая коллекция, которую можно распаковать. 

`*args` содержит все переданные в функцию позиционные аргументы (в нашем случае это 1, 2, 3). А `**kwargs` (от слова "keyworded") хранит все именованные аргументы (`k1`, `k2`). Распаковку и упаковку коллекций мы обсудим в следующих главах.

## Резюмируем
- Для объявления функции используется ключевое слово `def`, после которого идут имя функции, параметры и тело функции.
- Аргументы функции бывают позиционными и именованными.
- В функцию можно передавать аргументы по ссылке и по значению. Это зависит не от синтаксиса объявления или вызова функции, а от типа передаваемого в функцию объекта.
- Объекты неизменяемых типов передаются в функцию по значению. Объекты изменяемых типов передаются по ссылке.
- Функция может возвращать произвольное количество значений. В таком случае они неявно оборачиваются в кортеж.
- Для документирования поведения функции используется docstring — комментарий в начале тела функции. 
- Функции в питоне могут быть вложенными. Таким образом достигается инкапсуляция кода.
- Вложенные функции имеют доступ к аргументам и переменным своей внешней функции.
- Лямбда-функции — это функции-однострочники вида `lambda параметры : выражение`.
- PEP8 не рекомендует использовать лямбды, потому что они запутывают трейсбэк: вместо явного имени функции в трейсбэк попадает абстрактная `<lambda>`.
