# Глава 5. Вложенные функции, лямбды, вариативные функции

В этой главе мы глубже копнем тему функций. Обсудим, для чего нужны вложенные функции, стоит ли злоупотреблять лямбдами и как выглядят вариадики — функции с переменным числом аргументов.

## Вложенные функции
В питоне функции могут быть вложенными (inner, nested), то есть объявленными внутри другой функции:

```python
def outer_f():
    def inner_f():
        print("This is inner function")
    
    inner_f()

outer_f()
inner_f()
```

В данном примере вызов `outer_f()` завершится успешно, а вызов `inner_f()` строчкой ниже приведет к исключению:

```
NameError: name 'inner_f' is not defined
```

Пример показывает, что вложенные функции скрыты от от внешнего доступа. Таким образом достигается инкапсуляция вспомогательного кода: он исключается из глобальной области видимости.

Итак, вложенные функции нельзя вызывать извне. Но сами они имеют доступ к аргументам и локальным переменным функции-обертки!

```python
def count_vowels(s, n = None):
    def is_vowel():
        return s[n - 1].lower() in ['a', 'e', 'i', 'o', 'u']

    if n is None:
        n = len(s)
    
    if n == 1:
        return is_vowel()

    return count_vowels(s, n - 1) + is_vowel()
```

В этом примере вложенная функция `is_vowel()` работает с параметрами `s` и `n`. Мы видим, что вложенная функция имеет доступ к параметрам и переменным внешней функции. Это знание нам пригодится, когда в следующих главах мы будем обсуждать **замыкания** (closures) — вложенные функции, которые ссылаются на переменные, объявленные в теле внешней функции.

Напишите функцию `calc_gcd(a, b)`, которая находит наибольший общий делитель (GCD, greatest common divisor) чисел `a` и `b`. Функция должна быть рекурсивной и возвращать два значения: GCD и количество вызовов, которые были выполнены перед возвратом ответа. {.task_text}

Например, `calc_gcd(25, 15)` вернет 5 и 4, а `calc_gcd(8, 3)` вернет 1 и 5.  {.task_text}

Для подсчета количества вызовов заведите вложенную функцию. В своем решении реализуйте алгоритм Евклида. Он заключается в следующем: {.task_text}
- GCD равен `a`, если `a` и `b` совпадают.
- GCD равен `calc_gcd(a - b, b)`, если `a` больше `b`.
- GCD равен `calc_gcd(a, b - a)`, если `a` меньше `b`.

```python {.task_source #python_chapter_0050_task_0010}
```
```{.task_hint}
Вложенная функция на вход может принимать счетчик вызовов, инкрементировать его и возвращать в качестве одного из значений в return.
```

Кстати, автор питона Гвидо ван Россум в своей известной [презентации «Introduction to Python»](https://people.csail.mit.edu/rudolph/Teaching/Lectures/guido-intro-1.pdf) предложил вот такой лаконичный вариант поиска наибольшего общего делителя:

```python
def gcd(a, b):
    "greatest common divisor"
    while a != 0:
        a, b = b % a, a # parallel assignment
    return b
```
В примере от Гвидо применяется мощный инструмент питона: parallel assignment.

```python
a = x
b = y
```

Это прием, позволяющий запись выше сократить до одной строки:

```python
a, b = x, y
```

Parallel assignment особенно популярен, когда требуется выполнить swap — поменять значения двух переменных:

```python
x, y = y, x
```

## Лямбда-функции
Лямбда-функции (их также называют анонимными, безымянными) — это компактные функции-однострочники. Они могут иметь много параметров, но содержат только одно вычисляемое и возвращаемое выражение. Для возврата значения из лямбды `return` не используется. 

Если для объявления обычной именованной функции используется ключевое слово `def`, то для объявления лямбды — ключевое слово `lambda`:

```
lambda параметры : выражение
```

Пример объявления и вызова лямбда-функции, которая повторяет строку `s` `n` раз:

```python
mult_str = lambda s, n:  s * n
print(mult_str("*", 5))
```
```
*****
```

Здесь функциональному объекту `mult_str` присваивается безымянная лямбда-функция. На следующей строке функциональный объект вызывается. Эта лямбда-функция эквивалентна обычной функции, просто позволяет сэкономить немного места:

```python
def mult_str(s, n):
    return s * n
```

Ключевые слова, такие как `return` и `pass`, в лямбде использовать **нельзя.** Список параметров лямбды теоретически может быть и пустым:

```python
x = lambda: 5

print(x())
```
```
5
```

Вместо присваивания лямбды функциональному объекту ее можно сразу вызвать.

```python
(lambda s, n:  print(s * n))("I", 3)
```

Код выглядит странно, но выводит в консоль ожидаемый результат:

```
III
```

Напишите лямбда-функцию, которая принимает два числа `a` и `b`, возвращает их сумму и разность. Присвойте ее функциональному объекту `calc`. {.task_text}

Чтобы лямбда корректно вернула пару значений, явным образом положите их в кортеж: оберните возвращаемые значения в круглые скобки, необходимые для конструирования кортежа. {.task_text}

```python  {.task_source #python_chapter_0050_task_0020}
```
```{.task_hint}
calc = lambda a, b: (a + b, a - b)
```

Напишите лямбда-функцию, которая просто выводит в консоль `"Press any key to continue"`. Присвойте ее функциональному объекту `to_next_step`.  {.task_text}

Вызовите этот объект.  {.task_text}

```python  {.task_source #python_chapter_0050_task_0030}
```
```{.task_hint}
to_next_step = lambda : print("Press any key to continue")
```

Теперь вы узнаете лямбду, если увидите ее в чужом коде! Но стоит ли лямбдами злоупотреблять? В PEP8 [сказано следующее:](https://peps.python.org/pep-0008/#programming-recommendations) всегда используйте определение функций через `def` вместо того, чтобы присваивать лямбду функциональному объекту. PEP8 настаивает на тотальном избегании лямбд, такие дела.

Например, вот эту лямбду

```python
f = lambda x: 2 * x
```
PEP8 считает нужным превратить в полноценную функцию:
```python
def f(x): return 2 * x
```

С чем это связано? Да, лямбды действительно позволяют сэкономить немного места. Но взамен лишают вас понятного стека вызовов, усложняют процесс отладки. Потому что в стек вызовов вместо имени конкретной функции попадает весьма расплывчатое `<lambda>`. Так что выбирая между компактностью и понятностью, отдавайте предпочтение понятности.

Перепишите эту функцию в виде лямбды с внутренней лямбдой. Получится замыкание лямбды. Присвойте ее функциональному объекту `format_line`, для которого параметр `prefix` был бы равен `"a"`. {.task_text}

Чтобы его можно было вызвать следующим образом: `format_line(some_suffix)`. {.task_text}

```python  {.task_source #python_chapter_0050_task_0040}
def format_line(prefix):
    def inner(suffix):
        return f"{prefix} - {suffix}"
    return inner
```
```{.task_hint}
format_line = (lambda prefix : lambda suffix : f"{prefix} - {suffix}")("a")
print(format_line("b"))
```

## Вариативные функции {#block-variadic}
[Вариативные функции](/courses/python/chapters/python_chapter_0240) (variadic funcions) — это функции с переменным числом аргументов. Они реализованы в питоне и способны принимать произвольное количество позиционных и именованных аргументов:

```python
def f(*args, **kwargs):
    ...

f(1, 2, 3, k1="A", k2="B")
```

`args` и `kwargs` — популярные имена для вариативных позиционных и именованных аргументов. Символы звездочек `*` и `**` перед аргументами означают, что внутри переменной содержится некоторая коллекция, которую можно распаковать. 

`*args` содержит все переданные в функцию позиционные аргументы (в нашем случае это 1, 2, 3). А `**kwargs` (от слова keyworded) хранит все именованные аргументы (`k1`, `k2`). Распаковку и упаковку коллекций мы обсудим в [одной из следующих глав.](/courses/python/chapters/python_chapter_0230/)

Имплементируйте функцию `f`, которая принимает вариативные позиционные и именованные аргументы. В теле функции сначала проитерируйтесь по всем позиционным, а затем — по всем именованным аргументам, чтобы вывести их по одному в консоль. {.task_text}

```python  {.task_source #python_chapter_0050_task_0050}
```
```{.task_hint}
for x in args
```

## Резюмируем
- Функции в питоне могут быть вложенными. Таким образом достигается инкапсуляция кода.
- Вложенные функции имеют доступ к аргументам и переменным своей внешней функции.
- Лямбда-функции — это функции-однострочники вида `lambda параметры : выражение`.
- PEP8 не рекомендует использовать лямбды, потому что они запутывают стек вызовов: вместо явного имени функции в него попадает абстрактная `<lambda>`.
