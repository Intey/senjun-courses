# Глава 4. Встроенные типы данных: скалярные типы
> Всегда начинайте со структуры данных.  
Джон Кармак

В прошлых главах мы обсудили синтаксис питона. Самое время разобраться со структурами данных, встроенными в интерпретатор. Если однажды вы встанете перед дилеммой, применить ли встроенный в язык тип или пользовательский класс, то помните: в недрах интерпретатора CPython все встроенные типы — это оптимизированные структуры на языке C. Как следствие, они выигрывают по эффективности у пользовательских классов.

## Какие бывают типы данных
В питоне есть три категории типов:
- **Встроенные типы.** Для их использования не требуются дополнительные манипуляции вроде подключения модулей. Эти типы вшиты в интерпретатор. Например, целочисленный тип `int`.
- **Библиотечные типы,** доступные после импорта стандартных модулей языка. Эти типы — неотъемлемая часть питона, но для их использования требуется подключение модуля через ключевое слово `import` (об этом позже). К таким типам например относится `socket`, реализованный в одноименном модуле.
- **Пользовательские типы:** это любые классы из third-party модулей, которые устанавливаются менеджером пакетов, а также самописные классы из вашего кода. Например, `array` в библиотеке `numpy` для математических расчетов.

С этим знанием мы разберем, на какие категории делятся встроенные типы, и подробнее остановимся на одной из этих категорий.

## Изменяемые и не изменяемые типы
Самое важное, что нужно помнить про встроенные типы: они делятся на изменяемые (mutable) и неизменяемые (immutable). Любая сущность в питоне является объектом. Целое число — это объект, функция — это объект, исключение — объект... Любая переменная — это объект, то есть экземпляр конкретного класса. Когда объект инстанцируется, интерпретатор присваивает ему тип и уникальное число — id объекта. Эта судьба уготована даже целым числам и булевым флагам. Так вот, какие-то объекты в питоне могут менять свое состояние после инстанцирования и поэтому называются изменяемыми. А какие-то — не могут.

**Неизменяемые** встроенные типы: `int` (целое число), `float` (число с плавающей точкой), `complex` (комплексное число), `bool` (логическое значение), `NoneType` (неопределенное значение `None`), `str` (строка), `tuple` (кортеж), `frozenset` (неизменяемое множество).
**Изменяемые** встроенные типы: `list` (список), `set` (множество), `dict` (словарь).

Смотрите, `int` и `str` — неизменяемые! Так что же, над ними нельзя проводить операций вроде инкремента и конкатенации? Можно, но под капотом интерпретатора это будет означать замену одного объекта на другой объект этого же типа с новым id.

Чтобы это доказать, воспользуемся двумя встроенными функциями: `id()` и `type()`.
`id()` возвращает id объекта:
```python
lang = "ru"
print(id(lang))
```
Этот код выведет произвольное целое число — id строкового объекта `lang`. Разумеется, от запуска к запуску число будет меняться. Например, вывод этого кода может выгляеть так:
```python
139799602438576
```
`type()` возвращает название класса (типа) объекта:
```python
is_connected = True
print(type(is_connected))
```
Результат вывода этого кода в консоль будет таким:
```python
<class 'bool'>
```

А теперь проведите эксперимент. Заведите переменную `count`, равную 5. Выведете в консоль ее тип. На следующей строчке выведите ее id. Затем инкрементируйте переменную.  {.task_text} 

Инкремент — это оператор `+= n`. Инкремент на 1: `+= 1`.  {.task_text}

После инкремента вновь выведите id переменной. Визуально убедитесь, что id переменной `count` до инкремента и после инкремента не совпадают. {.task_text} 
```python {.task_source #python_chapter_0040_task_0010}
```
```python {.task_hint}
Инкремент: count += 1
```

Как видите, эксперимент подтвердил тот факт, что `int` — незименяемый тип. После каждой модификации переменной она неявным образом заменяется на новую. Мы будем часто касаться изменяемости и неизменяемости встроенных типов, а пока перейдем к другой их классификации: на скаляры и коллекции.

## Скалярные типы и коллекции
Встроенные типы данных делятся на две категории: 
- Скалярные (их еще называют простые, неделимые).
- Коллекции (составные, структурированные).

Все **скалярные типы** в питоне неизменяемые. К ним относятся:
- Числа.
    - `int`. Целое число: -98, 0, 9361 и так далее.
    - `float`. Число с плавающей точкой: 3, 1e-7, 45.03455, -e5.
    - `complex`. Комплексное число: `-5.6 + 2j`.
- `bool`. Логическое значение (флаг): `True` и `False`.
- `NoneType`. Неопределенное значение переменной: `None`.

**Коллекции** в питоне предсталены списками (`list`, по сути массивы), множествами (`set`, наборы уникальных значений), их неизменяемыми вариациями (`frozenset`), а также словарями (`dict`, контейнеры пар ключ-значение). Но об этом в следующей главе.

## Создание объектов
Объекты в питоне создаются двумя способами. Способ первый: просто присвоить объекту какое-то значение. Вот как это выглядит на примере объявления логической переменной:
```python
x = False
```
Интерпретатор при этом сам выведет и присвоит наиболее подходящий тип. Способ второй: вызвать конструктор, имя которого совпадает с именем желаемого типа. Конструктор может инициализировать объект значением по умолчанию либо переданным в него значением, а также привести аргумент к требуемому типу. 

Инициализация логической переменной значением по умолчанию:
```python
x = bool()
```
Приведение значения с плавающей точкой к логическому значению:
```python
x = bool(9.9)
```

Второй способ применяется для приведения строки к числу, превращения значения с плавающей точкой в целое и прочих преобразований между типами:
```python
x = int(3.14)
```

Корректно присвойте целочисленной переменной `max_val` значение, вызвав конструктор с аргументом-строкой "255": {.task_text}
```python {.task_source #python_chapter_0040_task_0020}
```
```python {.task_hint}
max_val = int("255")
```

А теперь рассмотрим каждый из встроенных типов подробнее.

## Числа
Занимательный факт: размер целых чисел в питоне не ограничен. Точнее, ограничен лишь объемом свободной оперативки. Теперь вы знаете, какой язык выбрать, если попадется задачка на большие числа.

По умолчанию литералы целых чисел записываются в десятичной системе счисления: `month = 12`, `day = 31`. Чтобы явно задать другое основание, используются **префиксы:**
- `0b` — двоичные числа: `0b1101`.
- `0o` — восьмеричные числа: `0o732`.
- `ox` — шестнадцатеричные числа: `0xAFF9`.

Создайте переменную `hex_val`, значение которой соответствует 16, но записано в шестнадцатеричной системе счисления с правильным префиксом: {.task_text}
```python {.task_source #python_chapter_0040_task_0030}
```
```python {.task_hint}
hex_val = 0x10
```

Наиболее популярные **операторы для работы с числами:**
- `a = b` — присваивание.
- `a + b` — сложение.
- `a - b` — вычитание.
- `a += 1` — инкремент. Вместо `1` может быть любое число. Упрощенного варианта инкремента (`a++`) и декремента (`a--`) и в питоне **нет.**
- `a -= 1` — декремент.
- `a * b` — умножение.
- `a / b` — деление.
- `a // b` — целочисленное деление. 
- `a % b` — остаток от деления.
- `a ** b`, `pow(a, b)` — возведение в степень.
- `-a` — изменение знака. Запись `+a` тоже допустима, по сути ничего не делает, и применяется в редких случаях для улучшения восприятия формул.


Помимо инкремента и декремента, существуют и другие комбинированные операторы присваивания. Например `a *= b`, `a /= b`.

Наиболее популярные **функции для работы с числами:**
- `abs(a)` —  модуль числа.
- `round(a, b)` — округление значения `a`. Если задан второй аргумент — то до заданного в нем количества знаков после запятой. Если аргумент не задан, то до ближайшего целого.
- `divmod(a, b)` — возвращает два числа: частное и остаток от деления.
- `bin(val)`, `oct(val)`, `hex(val)` — перевод числа в заданную систему счисления.
- `int(s, base)` — конвертация строки в целое число в системе счисления с основанием `base` (если `base` не указан, подразумевается десятичная система). Если преобразование не удается, генерируется исключение `ValueError`.


Напишите функцию `to_fahrenheit(celsius)`. Она должна прпнимать `celsius` градусов Цельсия и возвращать соответствующее значение по шкале Фаренгейта. {.task_text}

Формула: °F = (°C × 9/5) + 32. {.task_text}


```python {.task_source #python_chapter_0040_task_0040}
```
```python {.task_hint}
fahrenheit = celsius * 9.0 / 5.0 + 32.0
```

Как и в большинстве других языков, в питоне числа сравниваются между собой через операторы `>`, `>=`, `<`, `<=`, `==`, `!=`. 

Математический факт: комплексные числа, в отличие от вещественных, нельзя сравнивать между собой на "больше/меньше". Поэтому операторы `>`, `>=`, `<`, `<=` к комплексным числам (тип `complex`) **не применимы.**

**Цепочки сравнений**

Удобство использования математических операторов в питоне вышло на новый уровень благодаря цепочкам сравнений (comparison operator chaining). Они позволяют связывать множество сравнений в единую последовательность. Внутри нее условия неявно соединяются логическим `and`:
```python
if 0 < val <= 12:
    print("...this value may be month")
```
Эта цепочка аналогична явному объединению с помощью `and`:
```python
if 0 < val and val <= 12:
    print("...this value may be month")
```

Превратите условие внутри `if` в цепочку сравнений: {.task_text}
```python  {.task_source #python_chapter_0040_task_0050}
x = 1999
if x < 2000 and x > 1899:
    print("XX century!")
```
```python {.task_hint}
1899 < x < 2000
```

Как видите, цепочки сравнений делают проверки более компактными и человекочитаемыми:
```python
lower_bound <= a < b < c <= upper_bound
```

Но не смотря на мнимую простоту, цепочки сравнений — настоящая россыпь подводных камней. Будьте внимательны и не попадайтесь в ловушки цепочек сравнения.

Ловушка **усложнение вместо упрощения** срабатывает, если цепочки сравнения запутывают код вместо того, чтобы упрощать.
Например, когда операторы в условии идут не от меньшего большему в формате `a < b <= c < d`, а перемешаны:
```python
if x < y > z:
    pass
```

Согласитесь, в данном случае отказ от цепочки сравнений в пользу встроенной функции `max()` делает код понятнее:
```python
if max(x, z) < y:
    pass
```

Ловушка **использование в сравнении непостоянного выражения** захлопывается, если в середину цепочки закрадывается выражение с побочными эффектами либо на одинаковых данных возвращающее разный результат. Дело в том, что цепочки сравнений не только делают код короче, но и неявно оптимизируют его.
Ожидаемо, что в этом примере функция `get_val()` вызовется дважды:
```python
if a < get_val() and get_val() <= b:
    pass
```

Если же заменить его на цепочку сравнений, то `get_val()` будет вызван только один раз:
```python
if a < get_val() <= b:
    pass
```

Помните это, если захотите переписать какое-то условие на цепочку сравнений.

Ловушка **нетранзитивные операторы** грозит при проверке, что три переменные имеют разные значения. Обратная задача (проверить, что переменные одинковы) действительно идеально укладывается в цепочку сравнений:
```python
if x == y == z:
    pass
```

Но сработает ли проверка на неравенство?
```python
if x != y != z:
    pass
```

Фактически она является заменой для `x != y and y != z`. Но это условие ничего не говорит о том, как соотносятся между собой `x` и `z`. Поэтому такая проверка работать не будет. А все потому, что с математической точки зрения равенство считается транзитивным отношением, а неравенство — нет.

Перепишите эту функцию, чтобы она возвращала правильный результат: `True`, если все 3 переменные не равны между собой. Иначе `False`. {.task_text}
```python {.task_source #python_chapter_0040_task_0060}
def not_eq(a, b, c):
    return a != b != c
```
```python {.task_hint}
a != b and b != c and a != c
```

**Битовые операторы**

К целым числам в питоне применимы битовые операторы:
- `a & b` — битовый "И": `1 & 4` равен 0, `1 & 5` - соответственно 1.
- `a | b` — битовый "ИЛИ": `1 | 4` дает 5.
- `~a` — битовый "НЕ". Инверсия битов числа: ~5 равен отрицательному числу -6 из-за особенностей представления целых чисел в памяти.
- `a ^ b` — битовый "исключающий ИЛИ" (XOR). `3 ^ 5` — это 6. 

Для битовых операторов существуют комбинированные операторы присванивания: `|=`, `&=` и так далее. Например, так выглядит извлечение из значения `val` 4 и 5 битов по маске:
```python
val &= 0b110000
```

Также в питоне реализованы оперторы побитового сдвига:
- `a << b` — сдвиг числа `a` влево на `b` битов. `5 << 1` — это 10.
- `a >> b` — сдвиг вправо. `5 >> 1` — это 2.

Что же касается чисел с плавающей точкой, то в модуле `math` содержится масса полезных функий для проведения математических вычислений. Но об этом позже.

А пока напишите функцию `is_eq_abs(a, b, eps)`, проверяющую два числа с плавающей точкой `a` и `b` на равенство c точностью `eps`. {.task_text}

Например, `is_eq_abs(37.001, 37.002, 0.1)` вернет `True`, а `is_eq_abs(37.001, 37.002, 1e-5)` вернет `False`. {.task_text}
```python {.task_source #python_chapter_0040_task_0070}
```
```python {.task_hint}
Модуль разности числел должен быть меньше или равен eps.
```

## Логические значения
В питоне есть два встроенных логических объекта-синглтона: `True` и `False`. Результат вычисления любого выражения в конечном итоге сводится к одному из них:
```python
print(10 > 9) # True
print(2 == 3) # False
```

Это относится и к блоку `if/else`. Пример проверки числа на четность:

```python
if val % 2 == 0:
    print("val is even")
else:
    print("val is odd")
```

К логическим значениям применимы операторы:
- `and` — "И". В C++ и некоторых других языках этот оператор имеет вид `&&`.
- `or` — "ИЛИ". В C++ это `||`.
- `not` — "НЕ".

Проверка, что дата удовлетворяет условиям, заданным некоей бизнес-логикой:
```python
weekend = is_weekend(date)

if day > 20 and not weekend:
    print("Good date for discounts!")
```

Напишите функцию `my_xor()`, которая принимает два флага и возвращает для них логический XOR. Например, `my_xor(True, False)` вернет `True`. {.task_text}
```python {.task_source #python_chapter_0040_task_0080}
```
```python {.task_hint}
XOR — это взаимоисключающее ИЛИ. Возвращает True только для различающихся аргументов, один из которых равен True.
```

## NoneType
В питоне к типу `NoneType` принадлежит единственный на всю программу объект-синглтон `None`. По смыслу это очередное воплощение `null` из Java, C# и других языков. Обозначает отсутсвие значения:
```python
discount = None
```

Пример небольшой функции-обертки над вызовом `int()` для случаев, если на вызывающей стороне вместо исключений хочется обрабатывать проверку на `None`:
```python
def safe_get_int(x):
    try:
        return int(x)
    except ValueError:
        return None

print(safe_get_int("20"))
print(safe_get_int("here we get none"))
```

Для проверки на `None` используется ключевое слово `is`:
```python
if x is None:
    print("Got None for x")
```

```python
if db_conn is not None:
    select_table_rows(db_conn)
```

Почему для сравнения с `None` мы используем `is`, а не `==`? `is` — ключевое слово, проверяющее, являются ли два объекта одним и тем же объектом в памяти. `is` сравнивает не значения, а id объектов. В принципе сравнение с `None` через `==` тоже сработает. Но так делать не рекомендуется: сравнение через `==` вернет предсказуемый результат для всех встроенных типов, но для пользовательских классов этот оператор может быть переопределен. В результате сравнение с `None` вернет не то, что вы ожидали, и вас ждут часы увлекательной отладки. Второй аргумент в пользу `is` — он банально быстрее, чем `==`. Поэтому возьмите за правило сравниваться с `None` через `is`.

Напишите функцию `left_shift(val, n)`, которая сдвигает `val` на `n` битов влево и возвращает результат. Но если `val` или `n` равны `None`, функция сразу возвращает `None`. {.task_text}
```python {.task_source #python_chapter_0040_task_0090}
```
```python {.task_hint}
Сдвиг влево: val << n
```

# Резюмируем
- Все типы данных в питоне относятся ко встроенным, библиотечным либо пользовательским.
- Встроенные типы делятся на скалярные и коллекции.
- Встроенные типы делятся на изменяемые и не изменяемые. Все скалярные типы — неизменяемые.
- Скалярные типы — это `int`, `float`, `complex`, `bool`, `NoneType`.
- Для многих типов данных в питоне существуют различные варианты конструкторов. Они либо инициализирует переменную значением по умолчанию, указанным значением, либо приводят аргумент к соответствующему типу.
- Инкремент и декремент в питоне выглядят так: `i += 1`, `j -= 1`.
- Если требуется сравнить несколько значений между собой, используйте цепочки сравнений: `2 < x < 6`.
- В питоне нет ограничения на размер целого числа.
- Сравнивать значение с `None` нужно через оператор `is`.
