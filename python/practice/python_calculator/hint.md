## Подход к выполнению практики

В этой подсказке приводятся указания по способу выполнения практики, описанному в разделе «Теория». Согласно этому способу вычисление алгебраического выражения состоит из трех этапов: токенизация, перевод в постфиксную форму, вычисление выражения в постфиксной форме.

## Представление токенов

Каждый токен можно представить в виде словаря с двумя обязательными ключами: `type` — тип токена (число, скобка и т.д.); `value` — значение токена. Тогда алгебраическое выражение представляется в виде списка токенов.


Например, строка с выражением `9.5-(1+3)` превращается в список:

```
[
    {
        "type": "operand",
        "value": 9.5
    },
    {
        "type": "operator",
        "value": "-"
    },
    {
        "type": "parenthesis"
        "value": "("
    },
    {
        "type": "operand",
        "value": 1
    },
    {
        "type": "operator",
        "value": "+"
    },
    {
        "type": "operand",
        "value": 3
    },
    {
        "type": "parenthesis",
        "value": ")"
    }
]
```

Для того, чтобы по исходному выражению составить список токенов, необходимо реализовать конечный автомат.

## Представление конечного автомата

КА для парсинга выражения на токены можно представить в виде словаря словарей. Ключи словаря верхнего уровня — числовые обозначения для возможных вариантов обрабатываемых символов. Например, 0 для цифр, 1 для точки, 2 для скобок и т.д. Значение по данному ключу — тоже словарь. В нем ключи  — это числовые обозначения вариантов текущего состояния. А значения — кортежи, содержащие 2 элемента: обозначение нового состояния и функция, которую требуется выполнить при переходе между состояниями. Как вы помните, в питоне функции — это объекты первого порядка, то есть они могут быть присвоены переменной (в том числе, элементу кортежа).

Вот как может выглядеть КА в виде словаря словарей.

```python
{
    # Символ
    POINT: {
        # Текущее состояние        Новое состояние         Действие
        NEW_TOKEN:              (ERROR,                  None),
        NUMBER_INTEGER_PART:    (NUMBER_FRACTIONAL_PART, accumulate_number),
        NUMBER_FRACTIONAL_PART: (ERROR,                  None),
        ...
    },
    ...
}
```

Здесь `POINT` — константа, обозначающая, что мы обрабатываем символ точки, `NEW_TOKEN` — константа, обозначающая состояние обработки односимвольного токена, `accumulate_number` — функция, вызываемая при переходе к состоянию накопления числа. 

Допустим, конечный автомат представлен в виде словаря с именем `FSM` (finite-state machine). Тогда переключение между состояниями `cur_state` и `next_state` будет выглядеть так:

```python
tpl = FSM[cur_symbol][cur_state]

next_state = tpl[0]
action = tpl[1]
```

Здесь `cur_symbol` — численное обозначение обрабатываемого символа. Для его получения можно завести отдельную функцию, которая по символу возвращает его обозначение.


## Что использовать для реализации стека

Алгоритмы для перевода инфиксной формы в постфиксную и расчета выражения в постфиксной форме задействуют такую структуру данных как стек. В качестве стека вы можете использовать обычный список `list`. Вам пригодятся методы списка `append()` и `pop()`, а также встроенная функция `len()` для определения количества элементов.
