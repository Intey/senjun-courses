# Практика. Калькулятор алгебраических выражений

## Описание проекта

Необходимо реализовать функцию `calc(raw_expression)`. Она принимает строку `raw_expression` — алгебраическое выражение, состоящее из чисел, символов математических операций и скобок:

```
81.0-(2.5+1)/3
```

В строке могут содержаться пробелы:

```
4 - 5 * 0.3
```

Если в числе есть дробная часть, то она отделяется точкой: `71.45`.

Математическими операциями могут быть: сумма `+`, разность `-`, произведение `*`, деление `/`, возведение в степень `^`.

Приоритет операции возведения в степень выше, чем приоритет умножения и деления. А приоритет этих двух операций выше, чем у сложения и вычитания.

Функция `calc()` должна вернуть вещественное число — результат вычисленного выражения. Либо `None`, если выражение составлено некорректно. 

Считаем, что в выражении допущена ошибка, если скобки идут в неправильном порядке, не совпадает количество открывающих и закрывающих скобок, либо выражение содержит недопустимые символы.

## Примеры

Корректно составленное выражение:

```
(1 - 2.8)*3
```

Значение функции `calc()`:

```
-5.4
```

Выражение с пропущенной закрывающей скобкой:

```
(16 ^ 2*3
```

Выражение с недопустимыми символами:

```
5*a + b
```

Так как в этих двух выражениях есть ошибки, функция `calc()` для них возвращает `None`.

## Тестирование

Вы можете дописать свои варианты алгебраических выражений в скрипт `calc.py` и проверить, как ведет себя функция `calc()` на различных входных данных. Чтобы запустить скрипт `calc.py`, нажмите кнопку «Запустить».

Когда функция `calc()` будет готова к полноценному тестированию, нажмите кнопку «Отправить на проверку». По ней запустятся юнит-тесты из файла `test_calc.py`. В этом же файле можно посмотреть ожидаемые значения функции для набора алгебраических выражений.

## Теория

Калькулятор алгебраических выражений — классическое задание, которое дают студентам первых курсов, обучающимся программированию. Поэтому если вы знаете, как выполнить проект, можете сразу перейти к написанию кода и пропустить этот раздел. Здесь будет рассмотрен один из подходов к решению.

## Алгоритм вычисления выражения

Вычисление алгебраического выражения, представленного в виде строки, состоит из нескольких этапов: нормализация, токенизация, перевод в постфиксную форму, вычисление выражения в постфиксной форме.

### 1. Нормализация

**Нормализация** — предварительная подготовка входных данных, приведение их к единому виду. По условию задачи в строке могут содержаться пробелы. И для последующего более удобного разбора выражения эти пробелы нужно удалить. Поэтому нормализация строки сводится к удалению из нее всех пробелов.

Входные данные для нормализации — это исходная строка с алгебраическим выражением:

```
9.5 - (1 + 3)
```

На выходе — нормализованная строка:

```
9.5-(1+3)
```

### 2. Токенизация

**Токенизация** — лексический анализ строки, разбиение ее на токены. В контексте нашей задачи токен — это неделимая составляющая арифметического выражения: математический оператор, число (операнд), либо скобка.

Входные данные для токенизации — нормализованная строка:

```
9.5-(1+3)
```

На выходе — список составляющих ее токенов:

```
┌───────┐┌────────┐┌───────┐┌───────┐┌────────┐┌───────┐┌───────┐
│  9.5  ││    -   ││   (   ││  1    ││    +   ││   3   ││  )    │ 
└───────┘└────────┘└───────┘└───────┘└────────┘└───────┘└───────┘
 число    оператор  скобка   число    оператор  число    скобка
```

Токенизацию строки удобно проводить с помощью **детерминированного конечного автомата** (ДКА). Упрощенно он описывается как устройство, принимающее конечное число состояний. ДКА читает по одному символу за раз некую входную последовательность. В зависимости от текущего состояния и прочитанного символа ДКА меняет свое состояние. При переходе между состояниями ДКА может выполнять дополнительную логику. ДКА незаменим в случаях, когда требуется удобно и гибко описать последовательность обработки входных данных, перехода между состояниями и выполнения при этом каких-то действий.

Составим ДКА для токенизации арифметического выражения.

Его входная последовательность — это строка из цифр и символов `+`, `-`, `*`, `/`, `^`, `(`, `)`. Любой другой символ будем считать ошибочным. 

Возможные состояния ДКА: начало работы; прочитан односимвольный токен; накапливается целая часть числа; накапливается дробная часть числа; произошла ошибка.

При чтении ошибочного символа ДКА из любого состояния переходит в состояние ошибки. При чтении точки из состояния накопления целой части числа ДКА переходит к накоплению дробной части. А из состояния накопления дробной части — в состояние ошибки. Потому что в записи одного числа может быть только одна точка.

Подобным образом перечисляются все возможные переходы между состояниями и функции, которые должны вызываться при переходе. Например, при переходе из состояния чтения односимвольного токена этот токен добавляется в выходной список.

### 3. Перевод инфиксной формы выражения в постфиксную

Инфиксная запись означает, что операторы идут между операндами, и скобки изменяют приоритет вычислений: 

```
1 + 2
```

Алгоритмизировать вычисления выражений в такой записи — дело неблагодарное. Зато для вычисления выражений в постфиксной записи известен очень простой алгоритм. Постфиксная форма означает, что сначала идут операнды, а затем — оператор:

```
1 2 +
```

Постфиксная форма записи также [известна как](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C) обратная бесскобочная запись или польская инверсная запись.

Входные данные для построения постфиксной формы — это набор токенов, на которые разобрано выражение в инфиксной форме. Например, выражение `9.5-(1+3)`, представленное токенами:

```
┌───────┐┌────────┐┌───────┐┌───────┐┌────────┐┌───────┐┌───────┐
│  9.5  ││    -   ││   (   ││  1    ││    +   ││   3   ││  )    │ 
└───────┘└────────┘└───────┘└───────┘└────────┘└───────┘└───────┘
 число    оператор  скобка   число    оператор  число    скобка
```

На выходе — последовательность токенов, но уже в постфиксной форме.

```
┌───────┐┌────────┐┌───────┐┌────────┐┌────────┐
│  9.5  ││    1   ││   3   ││    +   ││    -   │
└───────┘└────────┘└───────┘└────────┘└────────┘
 число    число     число    оператор  оператор
```

Выражение `9.5-(1+3)` в постфиксной записи выглядит как `9.5 1 3 + -`.

Для преобразования инфиксной формы в постфиксную используется **алгоритм Дейкстры «Сортировочная станция».** Такое название он получил из-за сходства с действиями на железнодорожных сортировочных станциях. И вот как он выглядит.

**Шаг 1.** В цикле проходим по токенам: 

— Если токен — число или постфиксная функция (например, факториал `!`), добавляем его к выходному списку токенов.

— Если токен — префиксная функция (например, `sin` или `cos`), помещаем его в стек.

— Если токен — открывающая скобка, помещаем его в стек.

— Если токен — закрывающая скобка: пока верхним элементом стека не станет открывающая скобка, перекладываем из него токены в выходной список. Открывающая скобка удаляется из стека и не добавляется в выходной список. Если стек закончился и в нем не обнаружена открывающая скобка, то в алгебраическом выражении допущена ошибка: не согласованы скобки. Если допустимы разные виды скобок (например, `()`, `[]`, `{}`), появление непарной скобки тоже говорит об ошибке. Если какой-то тип скобок означает математическую функцию (например, `[5.6]` — целая часть числа 5.6), добавляем к выходному списку токен этой функции.

— Если токен — бинарная операция: пока соблюдается одно из нескольких условий, перемещаем токены из стека в выходной список. Вот эти условия: на вершине стека префиксная функция; либо операция на вершине стека имеет больший или равный данной операции приоритет; либо операция на вершине стека [левоассоциативна](https://ru.wikipedia.org/wiki/%D0%9E%D1%87%D0%B5%D1%80%D1%91%D0%B4%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B9) и имеет такой же приоритет. Затем помещаем токен с бинарной операцией в стек.

**Шаг 2.** Когда входная последовательность токенов закончилась, выталкиваем из стека все токены в выходной список. При этом стек должен содержать только токены операций. Если это не так, то в алгебраическом выражении допущена ошибка: не согласованы скобки.

После выполнения этих двух шагов в выходном списке сформировано алгебраическое выражение в постфиксной форме.

### 4. Вычисление выражения в постфиксной форме

На предыдущем этапе был получен список токенов алгебраического выражения в постфиксной форме. Осталось получить результат этого выражения. Воспользуемся **стековым алгоритмом вычисления выражения в постфиксной форме:**

В цикле проходим по токенам:

— Если токен — операнд (в нашем случае операндами могут быть только числа), он помещается в стек.

— Если токен — оператор, то выполняется заданная им операция. Для этого извлекается необходимое количество операций из стека, к ним применяется оператор, и результат вычисления помещается в стек. Важно помнить, что значение на вершине стека — это правый операнд, а не левый.

После выполнения этого цикла в стеке должно остаться единственное значение. Это и есть результат алгебраического выражения.
