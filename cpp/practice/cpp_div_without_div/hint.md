## Формальное описание алгоритма

Опишем шаги, которые нужно выполнить в теле функции `std::size_t divide(std::size_t a, std::size_t b)`.

Если `b` равен нулю, сразу возвращаем максимальное для типа `std::size_t` значение: `std::numeric_limits<std::size_t>::max()`. Так мы обрабатываем ситуацию деления на ноль.

Заводим переменную `res` типа `std::size_t` и инициализируем нулем. В ней мы будем накапливать результат целочисленного деления `a` на `b`.

В цикле, пока `a` больше или равно `b`, делаем три вещи:

[1] Находим `n` — количество бит, на которые можно сдвинуть `b` влево, чтобы вычесть из `a`. Для этого инициализируем `n` нулем. И заводим еще одну переменную: `b_next`, которая изначально равна `b << 1`. И во вложенном цикле, пока выполняются условия `a >= b_next` и `b < b_next`, увеличиваем `n` на единицу, а `b_next` еще раз сдвигаем вправо.

[2] Вычитаем сдвинутый на `n` бит влево `b` из `a`.

[3] Увеличиваем `res` на `2 ^ n`. То есть прибавляем к `res` единицу, сдвинутую на `n` бит влево. Единица — это литерал типа `std::size_t`: `1uz`.

После выхода из цикла в `res` будет содержаться результат целочисленного деления `a` на `b`. Возвращаем его из функции.
