## Формальное описание алгоритма

Опишем шаги, которые нужно выполнить в теле функции `std::size_t divide(std::size_t a, std::size_t b)`.

Если `b` равен нулю, сразу возвращаем максимальное для типа `std::size_t` значение: `std::numeric_limits<std::size_t>::max()`. Так мы обрабатываем ситуацию деления на ноль.

Заводим переменную `res` типа `std::size_t` и инициализируем нулем. В `res` мы будем накапливать результат целочисленного деления `a` на `b`.

В цикле пока `a` больше или равно `b` делаем три вещи:

[1] Находим `n` — количество бит, на которые можно сдвинуть `b` влево, чтобы вычесть из `a`. Для этого инициализируем `n` нулем. И в цикле пока выполняются условия `a >= (b << (n + 1))` и `b < (b << (n + 1))` увеличиваем `n` на единицу.

[2] Вычитаем сдвинутый на `n` бит влево `b` из `a`.

[3] Увеличиваем `res` на `2 ^ n`. То есть прибавляем к `res` единицу, сдвинутую на `n` бит влево. Единица — это литерал типа `std::size_t`: `1uz`.

После выхода из цикла в `res` будет содержаться результат целочисленного деления `a` на `b`. Возвращаем его из функции.
