# Практика. Деление без деления

## Описание проекта

Напишите функцию `divide()` в файле `div.h`. Она принимает два параметра `a` и `b` типа `std::size_t`. Функция должна вернуть результат целочисленного деления `a` и `b`.

В решении нельзя применять операторы деления `/`, умножения `*` и получения остатка `%`. Вместо них используйте побитовый сдвиг `<<`. О нем вы узнаете ниже в разделе «Теория».

Если `b` равен нулю, функция должна вернуть максимальное для типа `std::size_t` значение: `std::numeric_limits<std::size_t>::max()`. Что означает эта запись, вы узнаете уже в следующей главе.

Значения `a` и `b` находятся в диапазоне от 0 до `std::numeric_limits<std::size_t>::max() - 1`.

Ожидаемое поведение функции:

```c++
divide(6, 3); // 2
divide(3, 2); // 1
divide(7, 8); // 0
divide(1, 0); // std::numeric_limits<std::size_t>::max()
```

## Тестирование

По кнопке **«Запустить»** компилируется и запускается `main.cpp`. Внутри `main()` вы можете дописать свои варианты вызова `divide()` и проверить, как функция себя ведет на различных входных данных.

По кнопке **«Отправить на проверку»** выполняются юнит-тесты из файла `tests.cpp`. Запустите их, когда функция `divide()` будет готова к тестированию. В `tests.cpp` можно посмотреть ожидаемые значения функции для набора входных данных.

Проект будет засчитан как выполненный после успешного прохождения юнит-тестов.

## Теория

### Наивная реализация функции

Что такое целочисленное деление числа `a` на число `b`? По сути это вычитание `b` из `a` до тех пор, пока `a` не станет меньше `b`. Количество проделанных вычитаний и есть результат деления.

Этот алгоритм легко реализовать. Но представьте, что вы делите большое число на маленькое. В цикле придется сделать огромное количество вычитаний, прежде чем получится результат. Такой подход не оптимален: можно добиться сокращения количества итераций. И сделать это поможет оператор побитового сдвига.

### Побитовый сдвиг

Каждое число в памяти представлено в виде последовательности бит. Например, число 5 в бинарном представлении выглядит как `0b101`, 10 — это `0b1010`, а 7 — это `0b111`. Префикс `0b` в C++ используется для записи значений в двоичной системе счисления. Если вы плохо с ней знакомы, самое время [восполнить знания.]( https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F)

Побитовые операторы (bitwise operators) используются для манипуляции над отдельными битами значений. Они применимы только к целым числам.

Нас интересуют два побитовых оператора: `<<` — сдвиг влево и `>>` — сдвиг вправо.

Оператор `<<` — это **побитовый сдвиг влево.** Запись вида `x << n` означает, что каждый бит числа `x` сдвигается влево на `n` бит. Освобождающиеся биты заполняются нулями.

Например, если число 3 сдвинуть на 2 бита влево, мы получим 12:

```c++
3 << 2 // 12
```

Чтобы понять, откуда берется 12, взглянем на число 3 в двоичной системе счисления: `0b11`. Сдвиг `0b11` на 2 бита влево приводит к тому, что биты числа смещаются в сторону старших разрядов, а на их место устанавливаются нули: `0b1100`. Это и есть 12 в десятичной системе счисления.

Сдвиг числа на один бит влево аналогичен умножению на 2:

```c++
x << 1 == x * 2
```

Обобщим: сдвиг числа на `n` бит влево аналогичен умножению на 2 `n` раз, то есть умножению на 2 в степени `n` (`2 ^ n`).

Примеры:

```c++
4 << 3 // 32
1 << 4 // 16
```

Оператор `>>` — это **побитовый сдвиг вправо.** Запись `x >> n` означает, что биты числа `x` сдвигаются на `n` бит вправо. Для беззнаковых целых, таких как `std::size_t`, освобождающиеся биты заполняются нулями. Для знаковых целых, таких как `int`, поведение определяется реализацией в компиляторе (implementation-defined).

Как можно догадаться, операция сдвига вправо обратна сдвигу влево. И она аналогична целочисленному делению на `2 ^ n`:

```c++
9  >> 1 // 4
21 >> 2 // 5
```

Приоритет операторов побитового сдвига ниже, чем у сложения `+` и вычитания `-`. Но выше, чем у операторов сравнения `<`, `>`. Таблицу с приоритетом всех операторов вы можете [посмотреть на cppreference.](https://en.cppreference.com/w/cpp/language/operator_precedence)

### Реализация функции через побитовый сдвиг

При наивной реализации алгоритма деления мы в цикле уменьшали значение `a` на `b` до тех пор, пока `a` не станет меньше `b`. Теперь мы знаем про побитовый сдвиг и можем кратно сократить количество итераций цикла! Для этого нужно уменьшать `a` на значение `b`, домноженное на `2 ^ n`.

Но чему должно быть равно `n`? Его нужно вычислять на каждой итерации цикла. Он подбирается таким образом, чтобы не нарушалось условие: `a >= b * 2 ^ n`. Только тогда `b * 2 ^ n` можно вычесть из `a`.

И последнее, что нужно сделать: помимо уменьшения `a` увеличивать счетчик количества вычитаний `b` из `a`. Он и будет нашим результатом деления. Значение `a` на каждой итерации цикла уменьшается на `b * 2 ^ n`. Значит, счетчик должен увеличиваться на `2 ^ n`. Этого легко добиться с помощью побитового сдвига.

Если у вас возникнут проблемы при выполнении практики, воспользуйтесь подсказкой. Она доступна по кнопке со знаком вопроса.
