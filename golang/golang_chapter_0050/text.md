# Глава 5. Срезы 
Срез в Go реализует массив переменной длины. Вместо массива всегда лучше использовать срез, если только вам не нужно хранить фиксированное количество элементов. Срезы передаются в функции по ссылке, т. е. в функцию передается не копия среза (как в случае с массивом), а адрес этого среза. Изменения, внесенные в срез внутри функции, не будут потеряны по выходу из этой функции. Кроме того, такой прием существенно повышает быстродействие. 

Срез предоставляет доступ к подпоследовательности элементов массива. Чтобы объявить срез, необязательно для этого объявлять массив, однако массив все равно создается неявным образом. Этот массив называется базовым массивом. Срез состоит из указателя, длины и емкости. Указатель есть адрес первого элемента среза, который не обязан быть первым элементом массива. Длина — это количество элементов среза. Длина не превышает емкость. Емкость  — это количество элементов между началом среза и концом базового массива.

Вот так можно объявить и инициализировать срез:

```golang
slice := []int{1, 2, 3, 4, 5} 
```
Вот так можно объявить пустой срез из 10 элементов: 
```golang
slice := make([]int, 10) 
```
Очистить срез: 
```golang 
slice = nil 
```
Чтобы добавить элемент к срезу, можно воспользоваться встроенной функцией `append`:

```golang
slice = append(slice, 125)
```
Срезы, как и массивы, могут быть многомерными: 

```golang
slice := [][]int{{1, 2, 3}, {4, 5, 6}} 
```

Доступ к элементу с индексом `i` осуществляется также, как для массива. Через нотацию `[:]` можно выбрать несколько последовательных элементов среза. Вот так можно напечатать срез из элементов со значениями `2` и `3`: 

```golang
slice := []int{1, 2, 3, 4, 5}
fmt.Println(slice[1:3])
```

Первый индекс `1` включает данный элемент, второй индекс `3` не включает этот элемент. Таким образом, будут выбраны элементы с индексами `1` и `2`. Такое соглашение принято в языке Go всюду. Если не указать первое число в нотации `[:]`, то вместо него подставится нуль. Если не указать последнее число, то вместо него подставится длина среза:

```golang 
slice := []int{1, 2, 3, 4, 5}
fmt.Println(slice[:3])
```

Выведет:

```
[1 2 3]
```
Следующий код:
```golang 
slice := []int{1, 2, 3, 4, 5}
fmt.Println(slice[3:])
```

Выведет:

```
[4 5]
```

Важно! Когда мы используем нотацию `[:]`, то создается так называемый вторичный срез. Такой срез не является самостоятельным, он ссылается на исходный срез. Поэтому при изменении элементов вторичного среза, изменяться также и элементы исходного. 

Рассмотрим следующий пример. 

```golang
slice := []int{1, 2, 3, 4, 5}
slice2 := slice[1:3]
slice2[1] = 10

fmt.Println(slice)
```

Программа выведет следующий срез: 
```
[1 2 10 4 5]
```

Аналогично массивам, перебрать все элементы среза можно с помощью ключевого слова `range`. Узнать длину среза можно с помощью функции `len()`. Узнать емкость среза можно с помощью функции `cap()`.

Функция `Split` пакета `strings` позволяет разбить текст по некоторому разделителю и получить срез:

```golang
s := "1,2,3"
res := strings.Split(s, ",")
fmt.Println(res) 
```
Код выведет следующий срез: 
```
[1 2 3]
```

В переменной `s` типа `string` содержится некоторый текст. Допишите функцию `count`, которая подсчитает число слов в этом тексте. Словом считать любую последовательность символов, разделяемую пробелами. {.task_text}

```golang {.task_source #golang_chapter_0050_task_0010}
package main
import "fmt"

func count(){
    // ваш код здесь 
}

func main() {
	s := "Язык Go является регистрозависимым языком"
	fmt.Println(count(s))
}
```  

Воспользуйтесь функцией `strings.Split`. {.task_hint}

```golang {.task_answer}
package main

import (
	"fmt"
	"strings"
)

func count(s string) int {
	res := strings.Split(s, " ")
	return len(res)
}

func main() {
	s := "Язык Go является регистрозависимым языком"

	fmt.Println(count(s))
}
```

В переменной `slice` типа `[]uint` содержится некоторый срез. Реализуйте тело функции `maxEl`, которая принимает на вход срез данного типа и возвращает максимальный элемент. {.task_text}

```golang {.task_source #golang_chapter_0050_task_0020}
package main
import "fmt"

func maxEl(slice []uint) uint{
    // ваш код здесь 
}

func main() {
	slice := []uint{9, 10, 4, 2}

	fmt.Println(maxEl(slice))
}
```  

Объявите переменную типа `uint`. По умолчанию в ней лежит значение `0`. Это минимальное из возможных значений для переменной данного типа. Реализуйте цикл по всем элементам среза. Если внутри цикла найдется элемент больше, чем значение данной переменной, присвойте переменной это значение. По окончанию цикла верните значений переменной. {.task_hint}

```golang {.task_answer}
package main

import (
	"fmt"
)

func maxEl(slice []uint) uint {
	var res uint

	for _, el := range slice {
		if el > res {
			res = el
		}
	}

	return res
}

func main() {
	slice := []uint{9, 10, 4, 2}

	fmt.Println(maxEl(slice))

}
```

В переменной `slice` типа `[]uint16` содержится некоторый срез. Реализуйте тело функции `diff`, которая принимает на вход срез данного типа и возвращает разницу между максимальным и минимальным элементами среза. {.task_text}

```golang {.task_source #golang_chapter_0050_task_0030}
package main
import "fmt"

func diff(slice []uint16) uint16 {
    // ваш код здесь 
}

func main() {
	slice := []uint16{9, 10, 4, 2}

	fmt.Println(diff(slice))

}
```  

Максимальное значение для переменной типа `uint16` равно `65535`. {.task_hint}

```golang {.task_answer}
package main

import (
	"fmt"
)

func diff(slice []uint16) uint16 {
	var maxEl uint16
	var minEl uint16 = 65535

	for _, el := range slice {
		if el > maxEl {
			maxEl = el
		}
		if el < minEl {
			minEl = el
		}
	}

	return maxEl - minEl
}

func main() {
	slice := []uint16{9, 10, 4, 2}

	fmt.Println(diff(slice))

}

```

## Резюме 
1. В Go используются срезы, которые реализуют массивы переменной длины. Срезы могут быть как одномерными, так и многомерными. 
2. Срез представляет собой указатель, длину и емкость.
3. Срез всегда ссылается на базовый массив. 
4. Для обхода среза можно использовать ключевое слово `range`. 
5. Срезы обладают множеством достоинств по сравнению с массивами, поэтому их стоит использовать всюду, где заранее неизвестно хранимое количество элементов. 