# Классы типов

Если типы и значения – привычные понятия, которые можно найти в том или ином виде в любом языке программирования, то термин класс типов встречается не часто. У него нет аналогов и в обычном языке, поэтому я сначала постараюсь объяснить его смысл на примере.

В типизированном языке у каждой функции есть тип, но бывают функции, которые могут быть определены на аргументах разных типов; по сути, они описывают схожие понятия, но определены для значений разных типов. Например, функция сравнения на равенство, говорящая о том, что два значения одного типа `a` равны, имеет тип `a -> a -> Bool`, или функция печати выражения имеет тип `a -> String`, но что такое `a` в этих типах? Тип `a` является любым типом, для которого сравнение на равенство или печать (преобразование в строку) имеют смысл. Это понятие как раз и кодируется в классах типов. `Классы типов` (type class) позволяют определять функции с одинаковым именем для разных типов.

У классов типов есть имена. Также как и имена классов, они начинаются с большой буквы. Например, класс сравнений на равенство называется `Eq` (от англ. *equals* – равняется), а класс печати выражений имеет имя `Show` (от англ. *show* – показывать). Посмотрим на их определения:

Класс `Eq`:

```haskell
class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
```

Класс `Show`:

```haskell
class Show a where
    show :: a -> String
```

За ключевым словом `class` следует имя класса, тип-параметр и ещё одно ключевое слово `where`. Далее с отступами пишутся имена определённых в классе значений. Значения класса называются *методами*.

Мы определяем лишь типы методов, конкретная реализация будет зависеть от типа `a`. Методы определяются в экземплярах классов типов, мы скоро к ним перейдём.

Программистская аналогия класса типов это интерфейс. В интерфейсе определён набор значений (как констант, так и функций), которые могут быть применены ко всем типам, которые поддерживают данный интерфейс. К примеру, в интерфейсе “сравнение на равенство” для некоторого типа `a` определены две функции: равно `(==)` и не равно `(/=)` с одинаковым типом `a -> a -> Bool`, или в интерфейсе “печати” для любого типа `a` определена одна функция `show` типа `a -> String`.

Математическая аналогия класса типов это алгебраическая система. Алгебра изучает свойства объекта в терминах операций, определённых на нём, и взаимных ограничениях этих операций. Алгебраическая система представляет собой набор операций и свойств этих операций. Этот подход позволяет абстрагироваться от конкретного представления объектов. Например группа – это все объекты данного типа `a`, для которых определены значения: константа – единица типа `a`, бинарная операция типа `a -> a -> a` и операция взятия обратного элемента, типа `a -> a`. При этом на операции накладываются ограничения, называемые свойствами операций. Например, ассоциативность бинарной операции, или тот факт, что единица с любым другим элементом, применённые к бинарной операции, дают на выходе исходный элемент.

Давайте определим класс для группы:

```haskell
class Group a where
    e   :: a
    (+) :: a -> a -> a
    inv :: a -> a
```

Класс с именем `Group` имеет для некоторого типа `a` три метода: константу `e :: a`, операцию `(+) :: a -> a -> a` и операцию взятия обратного элемента `inv :: a -> a`.

Как и в алгебре, в Haskell классы типов позволяют описывать сущности в терминах определённых на них операций или значений. В примерах мы указываем лишь наличие операций и их типы, так же и в классах типов. Класс типов содержит набор имён его значений с информацией о типах значений.

Определив класс `Group`, мы можем начать строить различные выражения, которые будут потом интерпретироваться специфическим для типа образом:

```haskell
twice :: Group a => a -> a
twice a = a + a

isE :: (Group a, Eq a) => a -> Bool
isE x = (x == e)
```

Обратите внимание на запись `Group a =>` и `(Group a, Eq a) =>`. Это называется контекстом объявления типа. В контексте мы говорим, что данный тип должен быть из класса `Group` или из классов `Group` и `Eq`. Это значит, что для этого типа мы можем пользоваться методами из этих классов.

В первой функции `twice` мы воспользовались методом `(+)` из класса `Group`, поэтому функция имеет контекст `Group a =>`. А во второй функции `isE` мы воспользовались методом `e` из класса `Group` и методом `(==)` из класса `Eq`, поэтому функция имеет контекст `(Group a, Eq a) =>`.

## Контекст классов типов. Суперклассы

Класс типов также может содержать контекст. Он указывается между словом `class` и именем класса. Например

```haskell
class IsPerson a

class IsPerson a => HasName a where
    name :: a -> String
```

Это определение говорит о том, что мы можем сделать экземпляр класса `HasName` только для тех типов, которые содержатся в `IsPerson`. Мы говорим, что класс `HasName` содержится в `IsPerson`. В этом случае класс из контекста `IsPerson` называют *суперклассом* для данного класса `HasName`.

Это сказывается на контексте объявления типа. Теперь, если мы пишем

```haskell
fun :: HasName a => a -> a
```

Это означает, что мы можем пользоваться для значений типа `a` как методами из класса `HasName`, так и методами из класса `IsPerson`. Поскольку если тип принадлежит классу `HasName`, то он также принадлежит и `IsPerson`.

Запись `(IsPerson a => HasName a)` немного обманывает, было бы точнее писать `IsPerson a <= HasName a`, если тип `a` в классе `HasName`, то он точно в классе `IsPerson`, но в Haskell закрепилась другая запись.

# Экземпляры классов типов

В *экземплярах* (instance) классов типов мы даём конкретное наполнение для методов класса типов. Определение экземпляра пишется так же, как и определение класса типа, но вместо `class` мы пишем `instance`, вместо некоторого типа наш конкретный тип, а вместо типов методов – уравнения для них.

Определим экземпляры для `Bool`

Класс `Eq`:

```haskell
instance Eq Bool where
    (==) True  True  = True
    (==) False False = True
    (==) _     _     = False

    (/=) a b         = not (a == b)
```

Класс `Show`:

```haskell
instance Show Bool where
    show True  = "True"
    show False = "False"
```

Класс `Group`:

```haskell
instance Group Bool where
    e       = True
    (+) a b = and a b
    inv a   = not a
```

Отметим важность наличия свойств (ограничений) у значений, определённых в классе типов. Так, например, в классе типов “сравнение на равенство” для любых двух значений данного типа одна из операций должна вернуть “истину”, а другая “ложь”, то есть два элемента данного типа либо равны, либо не равны. Недостаточно определить равенство для конкретного типа, необходимо убедиться в том, что для всех элементов данного типа свойства понятия равенства не нарушаются.

На самом деле приведённое выше определение экземпляра для `Group` не верно, хотя по типам оно подходит. Оно не верно как раз из-за нарушения свойств. Для группы необходимо, чтобы для любого `a` выполнялось:

```haskell
 inv a + a == e
```

У нас лишь два значения, и это свойство не выполняется ни для одного из них. Проверим:

```haskell
    inv True   + True
 => (not True) + True
 => False      + True
 => and False    True
 => False

    inv False   + False
 => (not False) + False
 => True        + False
 => and True      False
 => False
```

Проверять свойства очень важно, потому что другие люди, читая ваш код и используя ваши функции, будут на них рассчитывать.
