# Функторы и монады: теория

Мы научились комбинировать функции наиболее общего типа `a -> b`. В этой главе мы посмотрим на специальные функции и способы их комбинирования. Специальными функциями мы будем называть такие функции, результат которых имеет некоторую известную нам структуру. Среди них функции, которые могут вычислить значение или упасть, или функции, которые возвращают сразу несколько вариантов значений. Для составления таких функций из простейших в Haskell предусмотрено несколько классов типов. Это функторы и монады. Их мы и рассмотрим в этой главе.

# Композиция функций

Центральной функцией этой главы будет функция композиции. Вспомним её определение для функций общего типа:

```haskell
(.) :: (b -> c) -> (a -> b) -> (a -> c)
f . g = \x -> f (g x)
```

Композиция двух функций `f` и `g` это такая функция, в которой мы сначала применяем `g`, а затем `f`. Для того чтобы тип функции стал более наглядным, мы определим эту функцию немного по-другому. Мы поменяем аргументы местами.

```haskell
(>>) :: (a -> b) -> (b -> c) -> (a -> c)
f >> g = \x -> g (f x)
```

Мы будем изображать функции кружками, а значения – стрелками. Значения словно текут от узла к узлу по стрелкам. Поскольку тип стрелки выходящей из `f` совпадает с типом стрелки входящей в `g` мы можем соединить их и получить составную функцию `(f >> g)`.

![Композиция функций](https://anton-k.github.io/ru-haskell-book/pic/6/fun1.png)

Композиция функций

## Класс Category

С помощью операции композиции можно обобщить понятие функции. Для этого существует класс `Category`:

```haskell
class Category cat where
    id   :: cat a a
    (>>) :: cat a b -> cat b c -> cat a c
```

Функция `cat` это тип с двумя параметрами, в котором выделено специальное значение `id`, которое оставляет аргумент без изменений. Также мы можем составлять из простых функций сложные с помощью композиции, если функции совпадают по типу. Здесь мы для наглядности также заменили метод `(.)` на `(>>)`, но суть остаётся прежней. Для любого экземпляра класса должны выполняться свойства:

```haskell
f  >> id  == f
id >> f   == f

f >> (g >> h) == (f >> g) >> h
```

Первые два свойства говорят о том, что `id` является нейтральным элементом для `(>>)` слева и справа. Третье свойство говорит о том, что нам не важно в каком порядке проводить композицию. Можно проверить, что эти правила выполнены для функций.

## Специальные функции

Все специальные функции, которые мы рассмотрим в этой главе будут иметь один и тот же тип:

```haskell
a -> m b
```

Смотрите вместо произвольного типа `b` функция возвращает `m b`. Единственное, что будет меняться от раздела к разделу это тип `m`. Добавив этот тип к результату, мы сузили область значений функции. Простым примером таких функций могут быть функции, которые возвращают списки:

```haskell
a -> [b]
```

Если раньше наши функции могли возвращать произвольное значение `b`, то теперь мы знаем, что все результирующие значения таких функций будут списками.

При этом для каждого такого `m` мы попытаемся построить свой замкнутый мир специальных функций `a -> m b`. Он будет жить внутри вселенной всех произвольных функций типа `a -> b`. В этом нам поможет специальный класс типов, который называется категорией Клейсли (эта конструкция носит имя математика Хенрика Клейсли).

```haskell
class Kleisli m where
    idK  :: a -> m a
    (*>) :: (a -> m b) -> (b -> m c) -> (a -> m c)    
```

Этот класс является классом `Category` в мире наших специальных функций. Если мы сотрём все буквы `m`, то мы получим обычные типы для тождества и композиции. В этом мире должны выполняться те же правила:

```haskell
f   *> idK  == f
idK *> f    == f

f *> (g *> h) == (f *> g) *> h
```
## Взаимодействие с внешним миром

С помощью класса `Kleisli` мы можем составлять из одних специальных функций другие. Но как мы сможем комбинировать специальные функции с обычными?

Поскольку слева у нашей специальной функции обычный общий тип, то с этой стороны мы можем воспользоваться обычной функцией композиции `>>`. Но как быть при композиции справа? Нам нужна функция типа:

```haskell
(a -> m b) -> (b -> c) -> (a -> m c)
```

Оказывается мы можем составить её из методов класса `Kleisli`. Мы назовём эту функцию композиции `(+>)`.

```haskell
(+>) :: Kleisli m => (a -> m b) -> (b -> c) -> (a -> m c)
f +> g = f *> (g >> idK)
```

С помощью метода `idK` мы можем погрузить в мир специальных функций любую обычную функцию.

## Три композиции

У нас появилось много композиций целых три:

```
аргументы                           |   результат 

обычная         >>  обычная         ==  обычная
специальная     +>  обычная         ==  специальная
специальная     *>  специальная     ==  специальная
```

При этом важно понимать, что по смыслу это три одинаковые функции. Они обозначают операцию последовательного применения функций. Разные значки отражают разные типы функций аргументов. Определим модуль `Kleisli.hs`

```haskell
module Kleisli where

import Prelude hiding (id, (>>))

class Category cat where
    id   :: cat a a
    (>>) :: cat a b -> cat b c -> cat a c

class Kleisli m where
    idK  :: a -> m a
    (*>) :: (a -> m b) -> (b -> m c) -> (a -> m c)    

(+>) :: Kleisli m => (a -> m b) -> (b -> c) -> (a -> m c)
f +> g = f *> (g >> idK)

-- Экземпляр для функций

instance Category (->) where
    id      = \x -> x
    f >> g  = \x -> g (f x)
```

Мы не будем импортировать функцию `id`, а определим её в классе `Category`. Также в `Prelude` уже определена функция `(>>)` мы спрячем её с помощью специальной директивы `hiding` для того, чтобы она нам не мешалась. Далее мы будем дополнять этот модуль экземплярами класса `Kleisli` и примерами.

# Примеры специальных функций
## Частично определённые функции

Частично определённые функции – это такие функции, которые определены не для всех значений аргументов. Примером такой функции может быть функция поиска предыдущего числа для натуральных чисел. Поскольку числа натуральные, то для нуля такого числа нет. Для описания этого поведения мы можем воспользоваться специальным типом `Maybe`. Посмотрим на его определение:

```haskell
data Maybe a = Nothing | Just a
    deriving (Show, Eq, Ord)
```

![Частично определённая функция](https://anton-k.github.io/ru-haskell-book/pic/6/maybe0.png)

Частично определённая функция

Частично определённая функция имеет тип `a -> Maybe b`, если всё в порядке и значение было вычислено, она вернёт `(Just a)`, а в случае ошибки будет возвращено значение `Nothing`. Теперь мы можем определить нашу функцию так:

```haskell
pred :: Nat -> Maybe Nat
pred Zero       = Nothing
pred (Succ a)   = Just a
```

Для `Zero` предыдущий элемент не определён .

### Составляем функции вручную

Значение функции `pred` завёрнуто в упаковку `Maybe`, и для того чтобы воспользоваться им нам придётся разворачивать его каждый раз. Как будет выглядеть функция извлечения дважды предыдущего натурального числа:

```haskell
pred2 :: Nat -> Maybe Nat
pred2 x = 
    case pred x of
        Just (Succ a) -> Just a
        _             -> Nothing
```

Если мы захотим определить `pred3`, мы заменим `pred` в `case`\-выражении на `pred2`. Не такое уж и длинное решение, но всё же мы теряем все преимущества гибких функций, все преимущества бесточечного стиля. Нам бы хотелось написать так:

```haskell
pred2 :: Nat -> Maybe Nat
pred2 = pred >> pred

pred3 :: Nat -> Maybe Nat
pred3 = pred >> pred >> pred
```

Но компилятор этого не допустит.

### Композиция

Для того чтобы понять как устроена композиция частично определённых функций изобразим её вычисление графически. Сверху изображены две частично определённых функции. Если функция `f` вернула значение, то оно подставляется в следующую частично определённую функцию. Если же первая функция не смогла вычислить результат и вернула `Nothing`, то считается что вся функция `(f*>g)` вернула `Nothing`.

![Композиция частично определённых функций](https://anton-k.github.io/ru-haskell-book/pic/6/maybe1.png)

Композиция частично определённых функций

Теперь давайте закодируем это определение в Haskell. При этом мы воспользуемся нашим классом `Kleisli`. Аналогом функции `id` для частично определённых функций будет функция, которая просто заворачивает значение в конструктор `Just`.

```haskell
instance Kleisli Maybe where
    idK    = Just
    f *> g = \a -> case f a of
                        Nothing -> Nothing
                        Just b  -> g b
```

Смотрите, в `case`\-выражении мы возвращаем `Nothing`, если функция `f` вернула `Nothing`, а если ей удалось вычислить значение и она вернула `(Just b)` мы передаём это значение в следующую функцию, то есть составляем выражение `(g b)`.

Сохраним это определение в модуле `Kleisli`, а также определение для функции `pred` и загрузим модуль в интерпретатор. Перед этим нам придётся добавить в список функций, которые мы не хотим импортировать из `Prelude` функцию `pred`, она также уже определена в `Prelude`. Для определения нашей функции нам потребуется модуль `Nat`, который мы уже определили. Скопируем файл `Nat.hs` в ту же директорию, в которой содержится файл `Kleisli.hs` и подключим этот модуль. Шапка модуля примет вид:

```haskell
module Kleisli where
    
import Prelude hiding(id, (>>), pred)
import Nat
```

Добавим определение экземпляра `Kleisli` для `Maybe` в модуль `Kleisli` а также определение функции `pred`. Сохраним обновлённый модуль и загрузим в интерпретатор.

```
*Kleisli> :load Kleisli
[1 of 2] Compiling Nat              ( Nat.hs, interpreted )
[2 of 2] Compiling Kleisli          ( Kleisli.hs, interpreted )
Ok, modules loaded: Kleisli, Nat.
*Kleisli> let pred2 = pred *> pred
*Kleisli> let pred3 = pred *> pred *> pred
*Kleisli> let two   = Succ (Succ Zero)
*Kleisli> 
*Kleisli> pred two
Just (Succ Zero)
*Kleisli> pred3 two
Nothing
```

Обратите внимание на то, как легко определяются производные функции. Желаемое поведение для частично определённых функций закодировано в функции `(*>)` теперь нам не нужно заворачивать значения и разворачивать их из типа `Maybe`.

Приведём пример функции, которая составлена из частично определённой функции и обычной. Определим функцию `beside`, которая вычисляет соседей для данного числа Пеано.

```
*Kleisli> let beside = pred +> \a -> (a, a + 2)
*Kleisli> beside Zero
Nothing
*Kleisli> beside two
Just (Succ Zero,Succ (Succ (Succ Zero)))
*Kleisli> (pred *> beside) two
Just (Zero,Succ (Succ Zero))
```

В выражении

```haskell
pred +> \a -> (a, a + 2)
```

Мы сначала вычисляем предыдущее число, и если оно есть составляем пару из `\a -> (a, a+2)`, в пару попадёт данное число и число, следующее за ним через одно. Поскольку сначала мы вычислили предыдущее число в итоговом кортеже окажется предыдущее число и следующее.

Итак с помощью функций из класса `Kleisli` мы можем составлять частично определённые функции в бесточечном стиле. Обратите внимание на то, что все функции кроме `pred` были составлены в интерпретаторе.

Отметим, что в `Prelude` определена специальная функция `maybe`, которая похожа на функцию `foldr` для списков, она заменяет в значении типа `Maybe` конструкторы на функции. Посмотрим на её определение:

```haskell
maybe              :: b -> (a -> b) -> Maybe a -> b
maybe n f Nothing  =  n
maybe n f (Just x) =  f x
```

С помощью этой функции мы можем переписать определение экземпляра `Kleisli` так:

```haskell
instance Kleisli Maybe where
    idM     = Just
    f *> g  = f >> maybe Nothing g
```
## Многозначные функции

Многозначные функции ветрены и непостоянны. Для некоторых значений аргументов они возвращают одно значение, для иных десять, а для третьих и вовсе ничего. В Haskell такие функции имеют тип `a -> [b]`. Функция возвращает список ответов. На рисунке изображена схема многозначной функции.

![Многозначная функция](https://anton-k.github.io/ru-haskell-book/pic/6/list0.png)

Многозначная функция

Приведём пример. Системы Линденмайера (или L-системы) моделируют развитие живого организма. Считается, что организм состоит из последовательности букв (или клеток). В каждый момент времени одна буква заменяется на новую последовательность букв, согласно определённым правилам. Так организм живёт и развивается. Приведём пример:

Аксиомы

Вывод

У нас есть два правила размножения клеток-букв в организме. На каждом этапе мы во всём слове заменяем букву $a$ на слово $a b$ и букву $b$ на $a$ . Начав с одной буквы $a$ , мы за несколько шагов пришли к более сложному слову.

Опишем этот процесс в Haskell. Для этого определим правила развития организма в виде многозначной функции:

```haskell
next :: Char -> String
next 'a' = "ab"
next 'b' = "a"
```

Напомню, что строки в Haskell являются списками символов. Теперь нам нужно применить многозначную функцию к выходу многозначной функции. Для этого мы воспользуемся классом `Kleisli`.

### Композиция

![Композиция многозначных функций](https://anton-k.github.io/ru-haskell-book/pic/6/list1.png)

Композиция многозначных функций

Определим экземпляр класса `Kleisli` для списков. На рисунке изображена схема композиции в случае многозначных функций. После применения первой функции `f` мы применяем функцию к каждому элементу списка, который был получен из `f`. Так у нас получится список списков. Но нам нужен список, для этого мы после применения `g` объединяем все значения в один большой список. Отметим, что функции `f` и `g` в зависимости от значений могут возвращать разное число значений, поэтому на выходе у функций `g` разное число стрелок.

Закодируем эту схему в Haskell:

```haskell
instance Kleisli [] where
    idK     = \a -> [a]
    f *> g  = f >> map g >> concat
```

Функция тождества принимает одно значение и погружает его в список. В композиции мы сначала применяем `f`, затем к каждому элементу списка результата применяем `g`, так у нас получается список списков. После чего мы сворачиваем его в один список с помощью функции `concat`.

Вспомним тип функций `map` и `concat`:

```haskell
map     :: (a -> b) -> [a] -> [b]
concat  :: [[a]] -> [a]
```

С помощью композиции мы можем получить n-тое поколение так:

```haskell
generate :: Int -> (a -> [a]) -> (a -> [a])
generate 0 f = idK
generate n f = f *> generate (n - 1) f
```

Или мы можем воспользоваться функцией `iterate` и написать это определение так:

```haskell
generate :: Int -> (a -> [a]) -> (a -> [a])
generate n f = iterate (*> f) idK !! n
```

Функция `iterate` принимает функцию вычисления следующего элемента и начальное значение и строит бесконечный список итераций:

```haskell
iterate :: (a -> a) -> a -> [a]
iterate f a = [a, f a, f (f a), f (f (f a)), ...]
```

Если мы подставим наши аргументы то мы получим список:

```haskell
[id, f, f*>f, f*>f*>f, f*>f*>f*>f, ...]
```

Проверим как работает эта функция в интерпретаторе. Для этого мы сначала дополним наш модуль `Kleisli` определением экземпляра для списков и функциями `next` и `generate`:

```
*Kleisli> :reload
[2 of 2] Compiling Kleisli          ( Kleisli.hs, interpreted )
Ok, modules loaded: Kleisli, Nat.
*Kleisli> let gen n = generate n next 'a'
*Kleisli> gen 0
"a"
*Kleisli> gen 1
"ab"
*Kleisli> gen 2
"aba"
*Kleisli> gen 3
"abaab"
*Kleisli> gen 4
"abaababa"
```

Правила L-системы задаются многозначной функцией. Функция `generate` позволяет по такой функции строить произвольное поколение развития буквенного организма.

# Применение функций

Давайте определим в терминах композиции ещё одну полезную функцию. А именно функцию применения. Вспомним её тип:

```haskell
($) :: (a -> b) -> a -> b
```

Эту функцию можно определить через композицию, если у нас есть в наличии постоянная функция и единичный тип. Мы будем считать, что константа это функция из единичного типа в значение. Превратив константу в функцию мы можем составить композицию:

```haskell
($) :: (a -> b) -> a -> b
f $ a = (const a >> f) ()
```

В самом конце мы подставляем специальное значение `()`. Это значение единичного типа (unit type) или кортежа с нулём элементов. Единичный тип имеет всего одно значение, которым мы и воспользовались в этом определении. Зачем такое запутанное определение, вместо привычного `(f a)`? Оказывается точно таким же способом мы можем определить применение в нашем мире специальных функций `a -> m b`.

Применение в этом мире происходит особенным образом. Необходимо помнить о том, что второй аргумент функции применения, значение, которое мы подставляем в функцию, также было получено из какой-то другой функции. Поэтому оно будет иметь такую же форму, что и значения справа от стрелки. В нашем случае это `m b`.

Посмотрим на типы специальных функций применения:

```haskell
(*$) :: (a -> m b) -> m a -> m b
(+$) :: (a -> b)   -> m a -> m b
```

Функция `*$` применяет специальную функцию к специальному значению, а функция `+$` применяет обычную функцию к специальному значению. Определения выглядят также как и в случае обычной функции применения, мы только меняем знаки для композиции:

```haskell
f  $ a = (const a >> f) ()
f *$ a = (const a *> f) ()
f +$ a = (const a +> f) ()
```

Теперь мы можем не только нанизывать специальные функции друг на друга но и применять их к значениям. Добавим эти определения в модуль `Kleisli` и посмотрим как происходит применение в интерпретаторе. Одна тонкость заключается в том, что мы определяли применение в терминах класса `Kleisli`, поэтому правильно было написать типы новых функций так:

```haskell
infixr 0 +$, *$

(*$) :: Kleisli m => (a -> m b) -> m a -> m b
(+$) :: Kleisli m => (a -> b)   -> m a -> m b
```

Также мы определили приоритет выполнения операций.

Загрузим в интерпретатор:

```
*Kleisli> let three = Succ (Succ (Succ Zero))
*Kleisli> pred *$ pred *$ idK three
Just (Succ Zero)
*Kleisli> pred *$ pred *$ idK Zero
Nothing
```

Обратите внимание на то как мы погружаем в мир специальных функций обычное значение с помощью функции `idK`.

Вычислим третье поколение L-системы:

```
*Kleisli> next *$ next *$ next *$ idK 'a'
"abaab"
```

Мы можем использовать и другие функции на списках:

```
*Kleisli> next *$ tail $ next *$ reverse $ next *$ idK 'a'
"aba"
```
## Применение функций многих переменных

С помощью функции `+$` мы можем применять к специальным значениям обычные функции одного аргумента. А что если нам захочется применить функцию двух аргументов?

Например если мы захотим сложить два частично определённых числа:

```haskell
?? (+) (Just 2) (Just 2)
```

На месте `??` должна стоять функция типа:

```haskell
?? :: (a -> b -> c) -> m a -> m b -> m c
```

Оказывается с помощью методов класса `Kleisli` мы можем определить такую функцию для любой обычной функции, а не только для функции двух аргументов. Мы будем называть такие функции словом `liftN`, где `N` – число, указывающее на арность функции. Функция `(liftN f)` “поднимает” (от англ. lift) обычную функцию `f` в мир специальных функций.

Функция `lift1` у нас уже есть, это просто функция `+$`. Теперь давайте определим функцию `lift2`:

```haskell
lift2 :: Kleisli m => (a -> b -> c) -> m a -> m b -> m c
lift2 f a b = ...
```

Поскольку функция двух аргументов на самом деле является функцией одного аргумента мы можем применить первый аргумент с помощью функции `lift1`, посмотрим что у нас получится:

```haskell
lift1       :: (a' -> b') -> m' a' -> m' b'
f           :: (a -> b -> c)
a           :: m a

lift1 f a   :: m (b -> c)  -- m' == m, a' == a, b' == b -> c
```

Теперь в нашем определении для `lift2` появится новое слагаемое `g`:

```haskell
lift2 :: Kleisli m => (a -> b -> c) -> m a -> m b -> m c
lift2 f a b = ...
    where g = lift1 f a
```

Один аргумент мы применили, осталось применить второй. Нам нужно составить выражение `(g b)`, но для этого нам нужна функция типа:

```haskell
m (b -> c) -> m b -> m c
```

Эта функция применяет к специальному значению функцию, которая завёрнута в тип `m`. Посмотрим на определение этой функции, мы назовём её `$$`:

```haskell
($$) :: Kleisli m => m (a -> b) -> m a -> m b
mf $$ ma = ( +$ ma) *$ mf
```

Вы можете убедиться в том, что это определение проходит проверку типов. Посмотрим как эта функция работает в интерпретаторе на примере частично определённых и многозначных функций, для этого давайте добавим в модуль `Kleisli` это определение и загрузим его в интерпретатор:

```
*Kleisli> :reload Kleisli
Ok, modules loaded: Kleisli, Nat.
*Kleisli> Just (+2) $$ Just 2
Just 4
*Kleisli> Nothing $$ Just 2
Nothing
*Kleisli> [(+1), (+2), (+3)] $$ [10,20,30]
[11,21,31,12,22,32,13,23,33]
*Kleisli> [(+1), (+2), (+3)] $$ []
[]
```

Обратите внимание на то, что в случае списков были составлены все возможные комбинации применений. Мы применили первую функцию из списка ко всем аргументам, потом вторую функцию, третью и объединили все результаты в список.

Теперь мы можем закончить наше определение для `lift2`:

```haskell
lift2 :: Kleisli m => (a -> b -> c) -> m a -> m b -> m c
lift2 f a b = f' $$ b
    where f' = lift1 f a
```

Мы можем записать это определение более кратко:

```haskell
lift2 :: Kleisli m => (a -> b -> c) -> m a -> m b -> m c
lift2 f a b = lift1 f a $$ b
```

Теперь давайте добавим это определение в модуль `Kleisli` и посмотрим в интерпретаторе как работает эта функция:

```
*Kleisli> :reload
[2 of 2] Compiling Kleisli          ( Kleisli.hs, interpreted )
Ok, modules loaded: Kleisli, Nat.
*Kleisli> lift2 (+) (Just 2) (Just 2)
Just 4
*Kleisli> lift2 (+) (Just 2) Nothing
Nothing
```

Как на счёт функций трёх и более аргументов? У нас уже есть функции `lift1` и `lift2` определим функцию `lift3`:

```haskell
lift3 :: Kleisli m => (a -> b -> c -> d) -> m a -> m b -> m c -> m d
lift3 f a b c = ...
```

Первые два аргумента мы можем применить с помощью функции `lift2`. Посмотрим на тип получившегося выражения:

```haskell
lift2       :: Kleisli m => (a' -> b' -> c') -> m a' -> m b' -> m c'
f           :: a -> b -> c -> d

lift2 f a b :: m (c -> d)   -- a' == a, b' == b, c' == c -> d
```

У нас опять появился тип `m (c -> d)` и к нему нам нужно применить значение `m c`, чтобы получить `m d`. Этим как раз и занимается функция `$$`. Итак итоговое определение примет вид:

```haskell
lift3 :: Kleisli m => (a -> b -> c -> d) -> m a -> m b -> m c -> m d
lift3 f a b c = lift2 f a b $$ c
```

Так мы можем определить любую функцию `liftN` через функции `liftN-1` и `$$`.

## Несколько полезных функций

Теперь мы умеем применять к специальным значениям произвольные обычные функции. Определим ещё несколько полезных функций. Первая функция принимает список специальных значений и собирает их в специальный список:

```haskell
import Prelude hiding (id, (>>), pred, sequence)

sequence :: Kleisli m => [m a] -> m [a]
sequence = foldr (lift2 (:)) (idK []) 
```

Мы “спрячем” из `Prelude` одноимённую функцию `sequence`. Посмотрим на примеры:

```
*Kleisli> sequence [Just 1, Just 2, Just 3]
Just [1,2,3]
*Kleisli> sequence [Just 1, Nothing, Just 3]
Nothing
```

Во второй команде вся функция вернула `Nothing` потому что при объединении списка встретилось значение `Nothing`, это равносильно тому, что мы объединяем в один список, значения полученные из функций, которые могут не вычислить результат. Поскольку значение одного из элементов не определено, весь список не определён.

Посмотрим как работает эта функция на списках:

```
*Kleisli> sequence [[1,2,3], [11,22]]
[[1,11],[1,22],[2,11],[2,22],[3,11],[3,22]]
```

Она составляет список всех комбинаций элементов из всех подсписков.

С помощью этой функции мы можем определить функцию `mapK`. Эта функция является аналогом обычной функции `map`, но она применяет специальную функцию к списку значений.

```haskell
mapK :: Kleisli m => (a -> m b) -> [a] -> m [b]
mapK f = sequence . map f
```