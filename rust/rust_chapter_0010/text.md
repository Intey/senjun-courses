# Глава 1. Ключевые факты
> The most loved programming language  
По версии ежегодного опроса разработчиков Stack Overflow Developer Survey с 2016 по 2023 год.

Глава посвящается ключевым фактам о языке программирования Rust. Она позволит составить первое впечатление о языке, узнать его плюсы и минусы.

## Что такое Rust
Rust — это компилируемый язык, поддерживающий множество парадигм программирования. Rust позволяет писать программы в функциональном и императивном стилях. Наследование типов в языке отсутствует, то есть классического ООП в Rust нет. Язык поддерживает обобщённые типы данных (generics). Обобщёнными в Rust могут быть функции, структуры и перечисления.

При создании языка ключевыми приоритетами были выбраны:
 + безопасность,
 + скорость,
 + параллелизм.

{.paragraph}

## Типизация
Безопасность в языке Rust обеспечивается строгой статической типизацией.

**Cтатическая типизация** определяет правило связывания типа с сущностями программы. При статической типизации переменная, параметр функции, возвращаемое значение функции связывается с типом в момент объявления и этот тип не может быть изменён позже.

Заведем целочисленную переменную `k` со значением 10, при помощи ключевого слова `mut` укажем, что она изменяемая:
```rust
let mut k = 10;
```
Теперь присвоим `k` новое значение -20.
```rust
k = -20;
```
По-умолчанию целочисленные литералы имеют тип `i32`, 32-х битное знаковое целое. Поэтому переменная `k` также будет иметь тип `i32`, новое значение -20 является допустимым. Однако, если попытаемся присвоить `k` строковый литерал:
```rust
k = "3";
```
То получим ошибку компиляции, т.к. нельзя изменить тип переменной `k` с целочисленного на строчный.

{.paragraph}

**Строгая (сильная)** типизация — это политика работы с типами, при которой не допускается смешивание сущностей разных типов в выражениях и не выполняются никакие автоматические преобразования.

Определим функцию `calc()`, которая возвращает значение входного аргумента, увеличенное на 10. Тип входного параметра и возвращаемого значения функции — 64 битное знаковое целое. Для возврата значения из функции ключевое слово `return` в Rust можно опустить.
```rust
fn calc (v: i64) -> i64 {
    v + 10
}
```
Затем передадим в функцию 64 битное знаковое целое:
```rust
let integer_64bit: i64 = 42;
let result = calc(integer_64bit);
```
Код скомпилируется без ошибок, тип входного параметра соответствует определенному в функции. Теперь попопробуем сделать то же самое с 32 битным знаковым целым:
```rust
let integer_32bit: i32 = 42;
let result = calc(integer_32bit);
```
Наверное это неожиданно, но компиляция завершится с ошибкой! Неявное преобразование из `i32` в `i64` недопустимо. Для таких случаев Rust требует явного преобразования типов:
```rust
let result = calc(integer_32bit as i64);
```

{.paragraph}

В Rust используется **явная** типизация. То есть при объявлении переменной требуется указывать её тип:
```rust
// 32 битное беззнаковое целое
let int: u32 = 100;

// переменная булевого типа
let flag: bool = false;
```

Однако можно опустить явное указание типа в тех случаях, когда компилятор способен вычислить тип переменной из инициализирующего выражения.
```rust
// 32 битное беззнаковое целое, явное указание типа
let val: u32 = 100;

// тип u32 определяется инициализирующим выражением
let double_val = 2 * val;
```

{.paragraph}

## Безопасная работа с памятью
Rust гарантирует безопасную работу с памятью благодаря встроенной в компилятор системе статической проверки ссылок (borrow checker). Это обеспечивается строгим выполнением правил **владения** (ownership) и **заимствования** (borrowing).

Правила **владения** подразумевают, что у каждого значения есть один и только один владелец в каждый момент времени.

Правила **заимствования** реализуют семантику *"либо много читателей, либо один писатель"*. Это означает, что для каждой переменной может существовать либо несколько заимствований (ссылок) на чтение, либо только одна на запись. Время жизни заимствования не может быть больше времени жизни заимствованного объекта.

{.paragraph}
 
Кроме того, обеспечивается контроль над использованием неинициализированных и деинициализированных переменных. Все проверки корректности выполнения правил владения и заимствования происходят во время компиляции. Если какое-то правило будет нарушено, то программа на Rust просто не скомпилируется.

Cтрогое выполнение правил владения и заимствования позволяет избежать ситуации, когда код программы обращается к удаленному либо не аллоцированному участку памяти (segmentation fault). Это проблема, хорошо знакомая C и C++ разработчикам. Кроме того, в Rust предусмотрена поддержка параллельного программирования с предотвращением гонки данных. Здесь также работают вышеописанные правила.

{.paragraph}

## Производительность
Rust создавался в том числе как язык системного программирования. А это подразумевает высокую производительность и рачительное использование доступных ресурсов. Высокой производительности программ на Rust способствует использование *абстракций с нулевой стоимостью*. Так, статическая проверка ссылок во время компиляции не порождает дополнительного исполняемого кода и не вызывает дополнительных накладных расходов во время работы программы.

{.paragraph}

В дополнение к этому в Rust поддерживается *move-семантика*. Это означает, что объект, расположенный на куче, при присваивании перемещается к новому владельцу (переменной), делая старого владельца недействительным (деинициализированная переменная). Например, если создать строковую переменную `s1` и присвоить её значение `s2`:
```rust
let s1 = String::from("moved value");
let s2 = s1;
```
То значение "moved value" будет перемещено к новому владельцу — `s2`. При этом `s1` станет деинициализированной и недоступной к использованию:
```rust
println!("{}", s1);
```
Попытка распечать значение `s1` приведет к ошибке компиляции. Но можно вывести на консоль значение `s2`:
```rust
println!("{}", s2);
```
В консоль будет выведено: `moved value`.

{.paragraph}

Использование move-семантики позволяет избежать лишнего копирования и дополнительных расходов во время исполнения программы. При этом есть возможность скопировать значение без перемещения. Для копирования (клонирования) значения нужно воспользоваться методом `clone()`:
```rust
let s1 = String::from("copied value");
let s2 = s1.clone();
println!("s1 = '{}', s2 = '{}'", s1, s2);
```
После клонирования обе переменные доступны, в консоль будет выведено: `s1 = 'copied value', s2 = 'copied value'`.

{.paragraph}

Для поддержки низкоуровневого программирования Rust разрешает объявлять функции и блоки кода как *небезопасные* (unsafe). Для небезопасного кода отключаются некоторые ограничения, что позволяет выполнять операции на более низком уровне. Но разработчик должен полностью понимать, что он делает. Для большинства задач `unsafe` не требуется и не рекомендуется к использованию. Иногда `unsafe` необходим, например, для подключения библиотек, написанных на языке C.

{.paragraph}
